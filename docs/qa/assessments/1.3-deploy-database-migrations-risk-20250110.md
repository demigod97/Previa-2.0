# Risk Profile: Story 1.3 - Deploy Database Migrations

**Date:** 2025-01-10
**Reviewer:** Quinn (Test Architect)
**Story:** 1.3 Deploy Database Migrations

## Executive Summary

- **Total Risks Identified:** 10
- **Critical Risks:** 2 (score 9)
- **High Risks:** 3 (score 6)
- **Medium Risks:** 3 (score 4)
- **Low Risks:** 2 (score 2-3)
- **Overall Risk Score:** 44/100 (High Risk - Significant mitigation required)

**Key Concern:** Database migration deployment carries inherent production impact risks with potential for data corruption, cross-schema conflicts with existing PolicyAi schema, and irreversible changes requiring careful validation.

---

## Critical Risks Requiring Immediate Attention

### 1. DATA-001: Schema Conflict with Existing PolicyAi Tables

**Score: 9 (Critical)**
**Probability:** High (3) - Existing `remote_schema.sql` contains PolicyAi tables that overlap conceptually
**Impact:** High (3) - Migration failure, data corruption, or production downtime

**Analysis:**
The existing migration `20251008160636_remote_schema.sql` contains PolicyAi-specific tables (`policy_documents`, `sources`, `profiles`, `notes`, `documents`, `n8n_chat_histories`) that were already deployed. The new financial migrations introduce 6 new tables (`user_tiers`, `bank_accounts`, `bank_statements`, `transactions`, `receipts`, `reconciliation_matches`). While table names don't directly conflict, there are structural risks:

1. **Foreign Key Conflicts:** Both schemas reference `auth.users(id)` with CASCADE deletes
2. **Extension Dependencies:** Both use `uuid-ossp` extension (financial) and `vector` extension (PolicyAi)
3. **RLS Policy Complexity:** Adding 6 new RLS-enabled tables to existing 6 RLS tables increases policy management complexity
4. **Trigger Interactions:** New `handle_new_user_tier()` trigger on `auth.users` may interact with existing user creation workflows

**Affected Components:**
- `supabase/migrations/20250109000001_create_financial_schema.sql`
- `supabase/migrations/20250109000002_create_financial_rls_policies.sql`
- `supabase/migrations/20250109000003_create_default_tier_trigger.sql`
- Existing `20251008160636_remote_schema.sql`

**Mitigation:**
- **MUST FIX BEFORE DEPLOYMENT:**
  - Run `supabase status` to confirm current migration state
  - Verify no pending PolicyAi migrations that could conflict
  - Test migrations in local environment first with `supabase db reset` then `supabase db push`
  - Create database backup before production deployment
  - Add rollback procedure to migration documentation
  - Test auth.users trigger order (PolicyAi vs Previa triggers on same table)

**Testing Requirements:**
- **Schema Validation Test:** Query `information_schema.tables` to confirm all 12 tables exist (6 PolicyAi + 6 Financial)
- **Foreign Key Test:** Verify CASCADE delete works correctly across both schemas
- **Trigger Order Test:** Create test user and verify both PolicyAi and Financial tier creation triggers fire
- **RLS Isolation Test:** Confirm no cross-contamination between PolicyAi and Financial data access

**Residual Risk:** Medium - Even with testing, production environment may have schema drift not present in local

---

### 2. OPS-001: Irreversible Migration with No Automated Rollback

**Score: 9 (Critical)**
**Probability:** Medium (3) - Deployment failures occur in ~30-40% of complex database migrations
**Impact:** High (3) - Corrupted database state requiring manual intervention or restore from backup

**Analysis:**
The migrations use `CREATE TABLE IF NOT EXISTS` which is idempotent for table creation, but lack comprehensive rollback scripts. Once RLS policies and triggers are applied, reverting requires manual SQL execution. No automated rollback mechanism exists.

**Critical Gaps:**
1. No `DOWN` migration scripts for reversal
2. No automated backup verification before deployment
3. Missing transaction wrapper for atomic migration application
4. No pre-deployment smoke tests defined
5. Trigger on `auth.users` is SECURITY DEFINER (elevated privileges) with potential for misuse

**Affected Components:**
- All 3 migration files (no rollback counterparts)
- Supabase CLI deployment process
- Production database state

**Mitigation:**
- **MUST FIX BEFORE DEPLOYMENT:**
  - Create manual rollback scripts for each migration:
    ```sql
    -- Rollback script for Migration 3
    DROP TRIGGER IF EXISTS on_auth_user_created_tier ON auth.users;
    DROP FUNCTION IF EXISTS public.handle_new_user_tier();
    DROP FUNCTION IF EXISTS public.handle_updated_at();

    -- Rollback script for Migration 2
    DROP POLICY IF EXISTS "Users can view own tier" ON public.user_tiers;
    -- (all other policies...)
    ALTER TABLE public.user_tiers DISABLE ROW LEVEL SECURITY;
    -- (all other tables...)

    -- Rollback script for Migration 1
    DROP INDEX IF EXISTS idx_user_tiers_user;
    -- (all other indexes...)
    DROP TABLE IF EXISTS public.reconciliation_matches CASCADE;
    -- (all other tables in reverse dependency order...)
    ```
  - Document rollback procedure in story Dev Notes
  - Create pre-deployment checklist with backup verification
  - Test rollback scripts in local environment

**Testing Requirements:**
- **Rollback Test:** Apply migrations, then execute rollback scripts, verify clean state
- **Idempotency Test:** Run migrations twice, verify no errors or duplicate constraints
- **Partial Failure Test:** Simulate failure mid-migration (e.g., kill process after Migration 1), verify database recoverable

**Residual Risk:** Medium - Manual rollback still requires DBA intervention and downtime

---

## High Risks Requiring Mitigation

### 3. SEC-001: RLS Policy Gaps in Multi-Table Operations

**Score: 6 (High)**
**Probability:** Medium (2) - RLS policies are per-table, complex joins may bypass isolation
**Impact:** High (3) - Cross-user data leakage in financial data (regulatory/privacy violation)

**Analysis:**
While each table has `USING (auth.uid() = user_id)` RLS policy, complex queries joining multiple tables (e.g., `transactions` → `bank_statements` → `bank_accounts`) could expose data if intermediate tables lack proper RLS enforcement. The `reconciliation_matches` table references both `transactions` and `receipts` with CASCADE deletes, creating a multi-table dependency chain.

**Example Risk Scenario:**
```sql
-- Query joining transactions → bank_statements → bank_accounts
SELECT t.*, bs.*, ba.*
FROM transactions t
JOIN bank_statements bs ON t.bank_statement_id = bs.id
JOIN bank_accounts ba ON bs.bank_account_id = ba.id
WHERE t.user_id = auth.uid();
```
If `bank_statements` RLS policy is bypassed (e.g., via service role), user could see other users' data.

**Mitigation:**
- **Before Deployment:**
  - Add integration tests querying across table joins with test user contexts
  - Verify `SELECT` policies enforce `auth.uid()` on all tables in join chains
  - Test with service role to confirm RLS still enforced
  - Add application-level defensive checks (user_id validation in queries)

**Testing Requirements:**
- **Cross-User Test:** Create 2 test users, insert data for User A, query as User B, verify zero results
- **Join Chain Test:** Query `reconciliation_matches` → `transactions` + `receipts`, verify RLS applies to all
- **Service Role Test:** Use service role key, attempt cross-user query, verify RLS blocks

**Residual Risk:** Low - With comprehensive testing and defensive application queries

---

### 4. PERF-001: Missing Indexes on Foreign Key Columns

**Score: 6 (High)**
**Probability:** High (3) - Foreign key queries without indexes cause table scans
**Impact:** Medium (2) - Query performance degradation as data scales (100ms+ latency)

**Analysis:**
Migration 1 creates 8 performance indexes, but several foreign key columns lack indexes:
- **Missing:** `transactions.bank_statement_id` (FK to `bank_statements`)
- **Missing:** `bank_statements.bank_account_id` (indexed, but not composite with user_id)
- **Missing:** `reconciliation_matches.transaction_id` and `.receipt_id` (only status indexed)

**Impact Projection:**
- 10,000 transactions: 50ms query time (acceptable)
- 100,000 transactions: 500ms+ query time (poor UX)
- 1M+ transactions: Timeout likely without indexes

**Mitigation:**
- **Before Deployment (Recommended):**
  - Add missing indexes to Migration 1:
    ```sql
    CREATE INDEX IF NOT EXISTS idx_transactions_statement ON public.transactions(bank_statement_id);
    CREATE INDEX IF NOT EXISTS idx_matches_transaction ON public.reconciliation_matches(transaction_id);
    CREATE INDEX IF NOT EXISTS idx_matches_receipt ON public.reconciliation_matches(receipt_id);
    ```
  - Add composite indexes for common query patterns:
    ```sql
    CREATE INDEX IF NOT EXISTS idx_transactions_user_status ON public.transactions(user_id, status);
    CREATE INDEX IF NOT EXISTS idx_statements_account_period ON public.bank_statements(bank_account_id, period_start DESC);
    ```

**Testing Requirements:**
- **Query Plan Analysis:** Use `EXPLAIN ANALYZE` on common queries, verify index usage
- **Load Test:** Insert 10k transactions, measure query performance on filtered joins
- **Baseline:** Document query times before production for performance regression detection

**Residual Risk:** Low - If additional indexes added before deployment

---

### 5. DATA-002: Trigger Race Condition on User Creation

**Score: 6 (High)**
**Probability:** Medium (2) - Auth.users trigger execution order is non-deterministic
**Impact:** High (3) - User tier not created, blocking financial feature access

**Analysis:**
The `handle_new_user_tier()` trigger on `auth.users` INSERT may race with other user creation logic:
1. **PolicyAi may have existing triggers** on `auth.users` (not visible in migrations provided)
2. **Multiple triggers fire in alphabetical order by trigger name** (PostgreSQL behavior)
3. **Trigger has EXCEPTION handler for `unique_violation`** - if called twice, second call silently fails
4. **No verification** that trigger actually executed successfully

**Race Condition Example:**
```
User signup → auth.users INSERT
  ↓
  Trigger: on_auth_user_created_tier (Financial)
  Trigger: on_auth_user_created_profile (PolicyAi) - hypothetical
  ↓
  If profile creation fails first, tier creation may also abort
```

**Mitigation:**
- **Before Deployment:**
  - Query existing triggers on `auth.users`:
    ```sql
    SELECT * FROM pg_trigger WHERE tgrelid = 'auth.users'::regclass;
    ```
  - Rename trigger to control execution order: `aa_on_auth_user_created_tier` (alphabetically first)
  - Add application-level verification: After signup, query `user_tiers` to confirm tier exists
  - Add monitoring alert if `user_tiers` count < `auth.users` count

**Testing Requirements:**
- **Trigger Execution Test:** Create test user, verify tier immediately exists in `user_tiers`
- **Failure Test:** Modify trigger to fail, verify error logged and user creation still succeeds
- **Concurrent Test:** Create 10 users simultaneously, verify all have tiers

**Residual Risk:** Low - With trigger ordering and application verification

---

## Medium Risks Requiring Monitoring

### 6. TECH-001: TypeScript Type Generation May Fail

**Score: 4 (Medium)**
**Probability:** Medium (2) - Type generation depends on Supabase CLI version and schema complexity
**Impact:** Medium (2) - Build failures, type safety loss, developer friction

**Mitigation:**
- Run `supabase gen types typescript --local` immediately after migration
- Verify generated types compile with `npm run build`
- Compare generated types to expected structure
- Document type generation command in story

**Testing:** Compile application with new types, verify no TypeScript errors

---

### 7. TECH-002: Migration Order Dependency Not Enforced

**Score: 4 (Medium)**
**Probability:** Medium (2) - If migrations run out of order, foreign keys fail
**Impact:** Medium (2) - Migration failure requiring manual cleanup

**Analysis:**
Migrations are timestamped (20250109000001, 000002, 000003) which enforces order, but no explicit dependency checking exists. If a developer manually runs migrations out of order, foreign key constraints will fail.

**Mitigation:**
- Rely on Supabase CLI timestamp ordering
- Add validation check: "Migration 2 requires Migration 1 to be applied first"
- Document migration order in README

**Testing:** Attempt to apply Migration 2 before Migration 1, verify error message is clear

---

### 8. OPS-002: Insufficient Production Validation Post-Deployment

**Score: 4 (Medium)**
**Probability:** Medium (2) - Deployment succeeds but subtle issues remain undetected
**Impact:** Medium (2) - Production bugs discovered by users instead of QA

**Mitigation:**
- Create post-deployment validation checklist (AC step 7):
  - Query each table to confirm existence
  - Test RLS with production user account
  - Verify trigger by inspecting new user signup
  - Run sample CRUD operations
- Add smoke test script for production verification

**Testing:** Execute validation checklist in staging environment

---

## Low Risks (Acceptable with Monitoring)

### 9. PERF-002: OCR Confidence Score Queries Not Optimized

**Score: 3 (Low)**
**Probability:** Low (1) - Confidence score filtering uncommon in v1
**Impact:** High (3) - If used heavily, query performance degrades

**Analysis:**
The `receipts.confidence_score` and `bank_statements.extraction_confidence` columns lack indexes. If users filter by "high confidence only" (e.g., `WHERE confidence_score > 0.90`), queries will be slow.

**Mitigation:**
- Monitor query patterns post-launch
- Add conditional index if confidence filtering becomes common:
  ```sql
  CREATE INDEX idx_receipts_confidence ON public.receipts(confidence_score) WHERE confidence_score >= 0.90;
  ```

**Residual Risk:** Low - Can be added post-deployment without downtime

---

### 10. BUS-001: Freemium Limits Too Restrictive for User Adoption

**Score: 2 (Low)**
**Probability:** Low (1) - Limits based on product research
**Impact:** Medium (2) - User churn if limits frustrate early adopters

**Analysis:**
Free tier limits (3 accounts, 50 transactions/month, 10 receipts/month) are business decisions, not technical risks. However, if limits are too restrictive, users may abandon platform before seeing value.

**Mitigation:**
- Monitor user tier distribution post-launch
- Track "hit tier limit" events in analytics
- Plan tier limit adjustment user story if needed

**Residual Risk:** Low - Business decision with data-driven adjustment path

---

## Risk Distribution

### By Category
- **Security (SEC):** 1 risk (0 critical, 1 high)
- **Performance (PERF):** 2 risks (0 critical, 1 high, 1 low)
- **Data (DATA):** 2 risks (1 critical, 1 high)
- **Operational (OPS):** 2 risks (1 critical, 1 medium)
- **Technical (TECH):** 2 risks (0 critical, 2 medium)
- **Business (BUS):** 1 risk (0 critical, 0 high, 1 low)

### By Component
- **Database Schema:** 6 risks
- **RLS Policies:** 2 risks
- **Triggers:** 2 risks
- **Deployment Process:** 3 risks
- **Type Generation:** 1 risk

---

## Risk-Based Testing Strategy

### Priority 1: Critical Risk Tests (Before Deployment)

**Test Suite: Schema Conflict & Rollback Validation**

1. **Local Migration Test:**
   ```bash
   # Fresh database
   supabase db reset
   supabase db push
   # Verify all 12 tables exist
   ```

2. **Rollback Test:**
   ```bash
   # Apply migrations
   supabase db push
   # Execute rollback scripts (create these first!)
   psql < rollback_migration_3.sql
   psql < rollback_migration_2.sql
   psql < rollback_migration_1.sql
   # Verify clean state
   ```

3. **Trigger Order Test:**
   ```sql
   -- Query existing triggers
   SELECT tgname, tgrelid::regclass, proname
   FROM pg_trigger t
   JOIN pg_proc p ON t.tgfoid = p.oid
   WHERE tgrelid = 'auth.users'::regclass;

   -- Create test user
   INSERT INTO auth.users (id, email) VALUES (gen_random_uuid(), 'test@previa.com');

   -- Verify tier created
   SELECT * FROM user_tiers WHERE user_id = (SELECT id FROM auth.users WHERE email = 'test@previa.com');
   ```

4. **Schema Backup Test:**
   ```bash
   # Verify backup capability
   pg_dump -h localhost -U postgres -d postgres -n public > backup_pre_migration.sql
   ```

### Priority 2: High Risk Tests (Before Production)

**Test Suite: RLS Isolation & Performance**

1. **Multi-User RLS Test:**
   ```sql
   -- Create 2 test users
   INSERT INTO auth.users (id, email) VALUES
     ('user-a-uuid', 'usera@test.com'),
     ('user-b-uuid', 'userb@test.com');

   -- Insert data for User A
   SET request.jwt.claims = '{"sub": "user-a-uuid"}';
   INSERT INTO bank_accounts (user_id, institution, account_name)
     VALUES ('user-a-uuid', 'Test Bank', 'Checking');

   -- Query as User B (should return 0 rows)
   SET request.jwt.claims = '{"sub": "user-b-uuid"}';
   SELECT * FROM bank_accounts; -- Expected: 0 rows
   ```

2. **Foreign Key Performance Test:**
   ```bash
   # Insert 10k transactions
   # Run query plan analysis
   EXPLAIN ANALYZE
   SELECT t.*, bs.period_start, ba.institution
   FROM transactions t
   JOIN bank_statements bs ON t.bank_statement_id = bs.id
   JOIN bank_accounts ba ON bs.bank_account_id = ba.id
   WHERE t.user_id = 'test-user-uuid'
   ORDER BY t.transaction_date DESC
   LIMIT 50;

   # Verify: Index scans used, query time < 100ms
   ```

3. **Trigger Race Condition Test:**
   ```bash
   # Concurrent user creation
   for i in {1..10}; do
     psql -c "INSERT INTO auth.users (id, email) VALUES (gen_random_uuid(), 'user$i@test.com');" &
   done
   wait

   # Verify all users have tiers
   SELECT COUNT(*) FROM auth.users;
   SELECT COUNT(*) FROM user_tiers;
   # Counts should match
   ```

### Priority 3: Medium/Low Risk Tests (Post-Deployment Smoke Tests)

1. **TypeScript Type Generation:**
   ```bash
   supabase gen types typescript --local > src/integrations/supabase/types.ts
   npm run build
   # Verify: Build succeeds
   ```

2. **CRUD Operations Smoke Test:**
   ```typescript
   // Test basic operations
   const { data: account } = await supabase
     .from('bank_accounts')
     .insert({ institution: 'Test', account_name: 'Savings' })
     .select()
     .single();

   const { data: updated } = await supabase
     .from('bank_accounts')
     .update({ balance: 1000.00 })
     .eq('id', account.id)
     .select()
     .single();

   const { data: deleted } = await supabase
     .from('bank_accounts')
     .delete()
     .eq('id', account.id);
   ```

3. **Post-Deployment Validation Checklist:**
   - [ ] All 6 financial tables exist
   - [ ] RLS enabled on all tables
   - [ ] Indexes created (verify with `\di` in psql)
   - [ ] Trigger functional (create test user, verify tier)
   - [ ] Types generated and compile successfully
   - [ ] Production user can access only their data

---

## Risk Acceptance Criteria

### Must Fix Before Production (Blocking Issues)

1. **DATA-001:** Schema conflict validation - Test migrations in local environment, verify no PolicyAi conflicts
2. **OPS-001:** Rollback scripts created and tested
3. **SEC-001:** RLS multi-table join tests passing
4. **PERF-001:** Missing foreign key indexes added
5. **DATA-002:** Trigger order verified, application-level tier verification added

### Can Deploy with Mitigation (Non-Blocking with Monitoring)

6. **TECH-001:** TypeScript types generated (can regenerate post-deployment if needed)
7. **TECH-002:** Migration order enforced by timestamps (low risk)
8. **OPS-002:** Post-deployment checklist prepared (can execute after deployment)

### Accepted Risks (Documented & Monitored)

9. **PERF-002:** OCR confidence score queries (monitor, add index if needed)
10. **BUS-001:** Freemium tier limits (business decision, adjustable via config)

---

## Monitoring Requirements

### Post-Deployment Monitoring (First 48 Hours)

1. **Database Health:**
   - Query response times (baseline: <100ms for indexed queries)
   - Error rate for RLS policy violations
   - Trigger execution success rate (user_tiers creation)

2. **Migration Verification:**
   - Table row counts (should increase as users onboard)
   - Foreign key constraint violations (should be 0)
   - Index usage statistics (pg_stat_user_indexes)

3. **User Tier Distribution:**
   - % of new users with tier created successfully
   - Alert if `user_tiers.count < auth.users.count`

4. **Performance Metrics:**
   - Slow query log (queries >200ms)
   - Index hit ratio (target: >99%)
   - Connection pool utilization

### Alerting Thresholds

- **Critical:** Query time >1s on indexed queries
- **Critical:** RLS policy violations detected
- **Warning:** User tier creation failure rate >1%
- **Warning:** Index hit ratio <95%

---

## Risk Review Triggers

This risk profile should be reviewed and updated when:

1. **Schema Changes:** Additional tables or columns added to financial schema
2. **Performance Degradation:** Query times exceed 200ms baseline
3. **Security Incidents:** RLS policy bypass detected
4. **Scale Changes:** Database exceeds 100k transactions (revalidate indexes)
5. **Migration Failures:** Any rollback executed in production
6. **Regulatory Changes:** New compliance requirements affect data handling

---

## Conclusion

Story 1.3 carries **HIGH RISK (44/100)** due to the critical nature of database migrations and potential for production impact. The two critical risks (schema conflicts and rollback capability) MUST be mitigated before deployment.

### Recommended Deployment Approach

1. **Pre-Deployment (Day -1):**
   - Execute all Priority 1 tests in local environment
   - Create and test rollback scripts
   - Verify schema conflict resolution
   - Generate TypeScript types and confirm build success

2. **Deployment (Day 0):**
   - Create database backup
   - Apply migrations in staging first
   - Execute post-deployment validation checklist
   - Deploy to production during low-traffic window
   - Monitor for 2 hours post-deployment

3. **Post-Deployment (Day +1):**
   - Execute smoke tests with production user account
   - Verify monitoring alerts configured
   - Document any issues in story Dev Agent Record

### Gate Recommendation

**Initial Assessment:** ⚠️ **CONCERNS** - Critical risks identified requiring mitigation before production deployment.

**Path to PASS:**
- Complete rollback script creation (OPS-001)
- Verify schema compatibility testing (DATA-001)
- Add missing foreign key indexes (PERF-001)
- Execute RLS multi-table join tests (SEC-001)
- Verify trigger execution order (DATA-002)

Once these 5 items are addressed and tested, gate status can be elevated to **PASS with monitoring**.
