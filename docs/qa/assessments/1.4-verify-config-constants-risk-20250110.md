# Risk Profile: Story 1.4 - Verify Config Constants

**Date:** 2025-01-10
**Reviewer:** Quinn (Test Architect)
**Story:** 1.4 Verify Config Constants

## Executive Summary

- **Total Risks Identified:** 7
- **Critical Risks:** 0 (score 9)
- **High Risks:** 2 (score 6)
- **Medium Risks:** 3 (score 4)
- **Low Risks:** 2 (score 2-3)
- **Overall Risk Score:** 74/100 (Moderate Risk - Manageable with standard testing)

**Key Observation:** Configuration constants are **low-complexity, high-value** code. The primary risks are consistency and correctness rather than technical complexity. This story is primarily about verification and validation rather than new implementation, which significantly reduces risk. The highest risks relate to **business logic errors** (wrong threshold values) and **consistency failures** (hardcoded values instead of constants).

---

## High Risks Requiring Mitigation

### 1. BUS-001: Incorrect Tier Limits Harm Revenue Model

**Score: 6 (High)**
**Probability:** Medium (2) - Constants already exist and appear correct, but no validation tests
**Impact:** High (3) - Incorrect free tier limits directly impact revenue (too generous = lost premium conversions, too restrictive = user churn)

**Analysis:**

The freemium business model depends on **precise tier limit enforcement**:
- **FREE tier:** 3 accounts, 50 transactions/month, 10 receipts/month
- **PREMIUM tier:** Effectively unlimited (999999)

If constants mismatch database schema OR are incorrectly applied in code:
- **Too generous free tier:** Users don't upgrade → Revenue loss
- **Too restrictive free tier:** Users abandon product → Churn
- **Mismatch with database:** RLS policies enforce different limits than UI shows → User confusion and support burden

**Current State:**
```typescript
// src/config/constants.ts
export const TIER_LIMITS = {
  FREE: {
    accounts: 3,
    transactionsPerMonth: 50,
    receiptsPerMonth: 10,
  },
  PREMIUM: {
    accounts: 999999,
    transactionsPerMonth: 999999,
    receiptsPerMonth: 999999,
  },
} as const;
```

**Database Schema (Migration 20250109000001):**
```sql
accounts_limit INTEGER DEFAULT 3,
transactions_monthly_limit INTEGER DEFAULT 50,
receipts_monthly_limit INTEGER DEFAULT 10
```

**Values match**, but **no automated validation** ensures they stay aligned.

**Affected Components:**
- `src/config/constants.ts` - Tier limit definitions
- Upload components - Enforce tier limits
- Database schema - `user_tiers` table defaults
- Upgrade prompts - Reference tier limits in messaging

**Mitigation:**

**IMMEDIATE (Before Deployment):**
1. **Create unit test to validate alignment:**
   ```typescript
   // Test that constants match database schema defaults
   it('FREE tier limits match database schema', () => {
     expect(TIER_LIMITS.FREE.accounts).toBe(3); // Migration default
     expect(TIER_LIMITS.FREE.transactionsPerMonth).toBe(50);
     expect(TIER_LIMITS.FREE.receiptsPerMonth).toBe(10);
   });
   ```

2. **Add E2E test for tier limit enforcement:**
   ```typescript
   // Test that free user cannot exceed limits
   test('free user hits account limit', async () => {
     // Create 3 accounts
     // Attempt to create 4th account
     // Verify error message references TIER_LIMITS.FREE.accounts
   });
   ```

3. **Add schema validation script:**
   ```bash
   # CI/CD check that constants match migration file
   grep "accounts_limit INTEGER DEFAULT" supabase/migrations/*.sql | grep "DEFAULT 3"
   # If migration changes, test fails
   ```

**ONGOING:**
- Add monitoring alert if `user_tiers` limits differ from constants
- Track premium conversion rate to validate tier limit effectiveness
- A/B test tier limits to optimize conversion (future story)

**Testing Requirements:**
- **Unit test:** Validate constants match database schema (1.4-UNIT-007)
- **E2E test:** Verify tier limit enforcement in upload flow (1.4-E2E-001)
- **Integration test:** Check error messages reference correct limits (1.4-UNIT-011)

**Residual Risk:** Low - With automated tests, risk reduces to code review oversight

---

### 2. TECH-001: Hardcoded Values in Codebase Bypass Constants

**Score: 6 (High)**
**Probability:** Medium (2) - Common in codebases without strict linting
**Impact:** High (3) - Inconsistent behavior, maintenance nightmare, configuration drift

**Analysis:**

If developers hardcode "magic numbers" instead of using constants, the application becomes inconsistent:

**Example Risk Scenario:**
```typescript
// ❌ BAD: Hardcoded value in upload component
if (file.size > 50 * 1024 * 1024) {
  showError('File too large');
}

// ✅ GOOD: Uses constant
if (file.size > MAX_FILE_SIZE) {
  showError(ERROR_MESSAGES.FILE_TOO_LARGE);
}
```

**Impact of Hardcoded Values:**
1. **Configuration Drift:** Changing `MAX_FILE_SIZE` doesn't affect hardcoded checks
2. **Inconsistent Errors:** Some errors show "50MB", others show "52MB" (different unit conversions)
3. **Maintenance Burden:** Need to find/replace all magic numbers when business rules change
4. **Testing Gaps:** Tests may pass with constants but production code uses hardcoded values

**Common Hardcoded Value Locations:**
- File upload validation (`50 * 1024 * 1024`)
- Tier limit checks (`3`, `50`, `10`)
- OCR confidence thresholds (`0.90`, `0.95`, `0.70`)
- Date range calculations (`3` days for matching)
- Amount tolerance (`0.50` for reconciliation)

**Affected Components:**
- All upload components (statements, receipts)
- Tier limit enforcement logic
- OCR processing workflows
- Reconciliation matching algorithm
- Error message displays

**Mitigation:**

**IMMEDIATE (Before Deployment):**
1. **Codebase audit for magic numbers:**
   ```bash
   # Search for hardcoded file sizes
   grep -rn "50.*1024.*1024" src/ --exclude-dir=config

   # Search for hardcoded tier limits
   grep -rn "\b3\b.*account\|50.*transaction\|10.*receipt" src/ --exclude-dir=config

   # Search for hardcoded thresholds
   grep -rn "0\.90\|0\.95\|0\.70" src/ --exclude-dir=config
   ```

2. **Add ESLint rule to prevent magic numbers:**
   ```javascript
   // .eslintrc.js
   rules: {
     'no-magic-numbers': ['error', {
       ignore: [0, 1, -1],
       ignoreArrayIndexes: true,
       enforceConst: true
     }]
   }
   ```

3. **Refactor hardcoded values to use constants:**
   ```typescript
   // Replace all instances found in audit
   import { MAX_FILE_SIZE, TIER_LIMITS, OCR_RECEIPT_DATA_THRESHOLD } from '@/config/constants';
   ```

**ONGOING:**
- Pre-commit hook runs magic number audit
- Code review checklist includes "No hardcoded values"
- CI/CD pipeline fails on ESLint magic number violations

**Testing Requirements:**
- **Integration test:** Codebase audit for hardcoded values (1.4-INT-001)
- **Unit test:** Verify components import constants (1.4-INT-002)
- **Regression test:** After refactoring, ensure no behavior changes

**Residual Risk:** Medium - Developers may still bypass linter with `// eslint-disable` comments

---

## Medium Risks Requiring Monitoring

### 3. TECH-002: Reconciliation Weights Don't Sum to 1.0

**Score: 4 (Medium)**
**Probability:** Low (1) - Constants already defined correctly in code
**Impact:** High (3) - AI matching algorithm produces incorrect confidence scores

**Analysis:**

The reconciliation matching algorithm uses weighted scoring:
```typescript
export const RECONCILIATION_WEIGHTS = {
  dateMatch: 0.40,    // 40% weight
  amountMatch: 0.40,  // 40% weight
  merchantMatch: 0.20, // 20% weight
} as const;
```

**Mathematical Requirement:** Weights MUST sum to 1.0 (100%)

**Current Sum:** 0.40 + 0.40 + 0.20 = 1.00 ✅

**Risk Scenario:**
If weights are changed in future (e.g., increase merchant matching importance) but sum ≠ 1.0:
```typescript
// ❌ BAD: Weights sum to 1.10
dateMatch: 0.40,
amountMatch: 0.50,  // Increased
merchantMatch: 0.20,
// Sum = 1.10 → Confidence scores inflated (95% shows as 104%)
```

**Impact:**
- **Confidence score inflation:** Scores > 1.0 break auto-approval threshold logic
- **Algorithm errors:** Normalization required in runtime (performance hit)
- **False positives:** Inflated scores cause incorrect auto-approvals

**Mitigation:**

**IMMEDIATE:**
```typescript
// Add unit test to validate weights sum
it('reconciliation weights sum to 1.0', () => {
  const sum = RECONCILIATION_WEIGHTS.dateMatch +
              RECONCILIATION_WEIGHTS.amountMatch +
              RECONCILIATION_WEIGHTS.merchantMatch;
  expect(sum).toBe(1.0);
});
```

**ONGOING:**
- Add JSDoc comment explaining sum requirement
- Code review checklist for weight changes
- Consider runtime assertion in matching algorithm

**Testing Requirements:**
- Unit test 1.4-UNIT-005 validates weight sum

**Residual Risk:** Very Low - Easily caught by unit test

---

### 4. BUS-002: OCR Thresholds Too High/Low for Real-World Performance

**Score: 4 (Medium)**
**Probability:** Medium (2) - Thresholds chosen without empirical testing
**Impact:** Medium (2) - Poor user experience (too many manual reviews or too many errors)

**Analysis:**

OCR confidence thresholds are **business decisions** based on assumptions:
- `OCR_ACCOUNT_NUMBER_THRESHOLD = 0.90` (90%)
- `OCR_RECEIPT_DATA_THRESHOLD = 0.90` (90%)

**Current Behavior:**
- **≥ 90%:** Auto-extract and use
- **< 90%:** Flag for manual review or re-upload

**Risk: Threshold Too High (>90%):**
- **Impact:** Too many manual reviews → Poor UX, low automation rate
- **Symptom:** Real-world OCR consistently scores 80-89% but is actually accurate
- **Example:** Bank statement with slightly tilted scan scores 88% but data is correct

**Risk: Threshold Too Low (<90%):**
- **Impact:** Too many errors extracted → Data corruption, user frustration
- **Symptom:** OCR scores 91% but frequently makes critical errors (wrong account number)
- **Example:** Receipt with faded ink scores 91% but merchant name is garbled

**Decision Basis:**
Per `TECHNICAL-DECISIONS.md#2`:
> "90% threshold balances automation with accuracy"

**But no empirical validation** with real bank statements and receipts.

**Affected Components:**
- Bank statement processing workflows
- Receipt OCR processing
- Manual review UI
- User onboarding (if first upload fails OCR)

**Mitigation:**

**SHORT-TERM (Post-Launch):**
1. **Collect OCR performance metrics:**
   ```typescript
   // Track: confidence score, actual accuracy (manual review), document type
   {
     confidence: 0.87,
     actualAccuracy: 'correct', // or 'incorrect'
     documentType: 'bank_statement',
     extractedField: 'account_number'
   }
   ```

2. **Analyze threshold effectiveness:**
   - Plot confidence score vs. actual accuracy
   - Find optimal threshold (maximize automation, minimize errors)
   - A/B test different thresholds with user cohorts

3. **Make thresholds configurable:**
   ```typescript
   // Allow dynamic adjustment without code deployment
   const threshold = await getFeatureFlag('ocr_threshold', 0.90);
   ```

**IMMEDIATE:**
- Document threshold as hypothesis in code comments
- Plan post-launch threshold optimization story
- Add monitoring for OCR confidence distribution

**Testing Requirements:**
- Unit test validates threshold values (1.4-UNIT-003)
- Post-launch: Collect real-world OCR performance data

**Residual Risk:** Medium - Won't know optimal threshold until production usage

---

### 5. OPS-001: Missing Documentation Causes Misuse of Constants

**Score: 4 (Medium)**
**Probability:** High (3) - Common without strong JSDoc discipline
**Impact:** Low (1) - Confusion, incorrect usage, but not critical failures

**Analysis:**

Configuration constants need **clear documentation** to prevent misuse:

**Example: Ambiguous Constant**
```typescript
// ❌ BAD: Unclear purpose
export const PROCESSING_TIMEOUT = 30;
```

Questions a developer might have:
- Is this in seconds, milliseconds, or minutes?
- When does this timeout apply? (OCR only? All processing?)
- What happens when timeout is reached?
- Can this be changed? What's the acceptable range?

**Example: Well-Documented Constant**
```typescript
// ✅ GOOD: Clear documentation
/**
 * Maximum time to wait for document processing (in seconds)
 * After this, show "processing" status and poll for completion
 *
 * @see docs/architecture/TECHNICAL-DECISIONS.md - Decision #4
 */
export const PROCESSING_TIMEOUT = 30; // seconds
```

**Impact of Poor Documentation:**
- Developer uses constant incorrectly (e.g., treats seconds as milliseconds)
- Business rules changed without understanding downstream effects
- New team members struggle to understand configuration

**Current Status:**
Most constants in `src/config/constants.ts` **have JSDoc comments** ✅
But some could be more detailed (e.g., gamification points lack justification)

**Mitigation:**

**IMMEDIATE:**
```bash
# Audit: Verify all exports have JSDoc
grep -E "^export const" src/config/constants.ts | while read line; do
  const_name=$(echo "$line" | awk '{print $3}')
  # Check for /** comment above export
  grep -B5 "export const $const_name" src/config/constants.ts | grep -q "/\*\*"
  if [ $? -ne 0 ]; then
    echo "Missing JSDoc: $const_name"
  fi
done
```

**ONGOING:**
- Add JSDoc completeness check to CI/CD
- Code review checklist includes documentation quality
- Link constants to technical decision documents

**Testing Requirements:**
- Unit test 1.4-UNIT-002 validates JSDoc exists

**Residual Risk:** Low - Documentation is ongoing effort

---

## Low Risks (Acceptable with Monitoring)

### 6. TECH-003: Type Safety Gaps Allow Invalid Values at Runtime

**Score: 3 (Low)**
**Probability:** Low (1) - TypeScript catches most issues at compile-time
**Impact:** High (3) - Runtime errors if invalid values bypass type system

**Analysis:**

TypeScript `const` assertion provides **compile-time immutability**:
```typescript
export const TIER_LIMITS = {
  FREE: { accounts: 3, ... },
  PREMIUM: { accounts: 999999, ... }
} as const;
```

**Compile-time protection:** ✅
```typescript
// TypeScript prevents:
TIER_LIMITS.FREE.accounts = 5; // Error: Cannot assign to readonly property
```

**Runtime protection:** ⚠️ Partial
```typescript
// JavaScript CAN mutate at runtime:
(TIER_LIMITS.FREE as any).accounts = 999;
console.log(TIER_LIMITS.FREE.accounts); // 999 (mutated!)
```

**Risk:** Low probability because:
1. TypeScript prevents accidental mutation
2. Need explicit `as any` cast to bypass
3. Linters flag `as any` casts for review

**But:** Runtime mutation still technically possible.

**Mitigation:**

**OPTIONAL (Defense-in-Depth):**
```typescript
// Add Object.freeze for runtime immutability
export const TIER_LIMITS = Object.freeze({
  FREE: Object.freeze({
    accounts: 3,
    transactionsPerMonth: 50,
    receiptsPerMonth: 10,
  }),
  PREMIUM: Object.freeze({
    accounts: 999999,
    transactionsPerMonth: 999999,
    receiptsPerMonth: 999999,
  }),
}) as const;

// Now runtime mutation throws error
(TIER_LIMITS.FREE as any).accounts = 999; // TypeError: Cannot assign to read only property
```

**Testing Requirements:**
- Unit test 1.4-UNIT-014 validates immutability

**Residual Risk:** Very Low - TypeScript + linting provide sufficient protection

---

### 7. PERF-001: Constant Imports Increase Bundle Size

**Score: 2 (Low)**
**Probability:** Low (1) - Tree-shaking removes unused exports
**Impact:** Medium (2) - Larger bundle → Slower page loads

**Analysis:**

`constants.ts` exports ~50 constants. If all are imported in every component:
```typescript
import * as constants from '@/config/constants';
// Imports ALL constants even if only using MAX_FILE_SIZE
```

**Bundle Size Impact:**
- Current constants file: ~10KB (with comments)
- Stripped (production): ~2KB
- With tree-shaking: ~0.5KB per import

**Risk:** Negligible if using named imports
```typescript
// ✅ GOOD: Tree-shaking removes unused exports
import { MAX_FILE_SIZE } from '@/config/constants';
```

**Mitigation:**

**IMMEDIATE:**
- Use named imports (already done in codebase ✅)
- Vite's tree-shaking handles optimization

**OPTIONAL (If bundle size becomes concern):**
- Split constants into category files:
  ```typescript
  import { MAX_FILE_SIZE } from '@/config/file-constants';
  import { TIER_LIMITS } from '@/config/tier-constants';
  ```

**Residual Risk:** Negligible - Modern bundlers handle this well

---

## Risk Distribution

### By Category
- **Business (BUS):** 2 risks (0 critical, 1 high, 1 medium)
- **Technical (TECH):** 3 risks (0 critical, 1 high, 2 medium)
- **Operational (OPS):** 1 risk (0 critical, 0 high, 1 medium)
- **Performance (PERF):** 1 risk (0 critical, 0 high, 0 low, 1 low)
- **Security (SEC):** 0 risks
- **Data (DATA):** 0 risks

### By Component
- **Configuration File:** 4 risks (constants.ts)
- **Upload Components:** 2 risks (tier limits, file size)
- **Reconciliation Algorithm:** 1 risk (weight sum)
- **Build System:** 1 risk (bundle size)

**Observation:** Low security/data risk because constants are **static configuration**, not user data or sensitive information.

---

## Risk-Based Testing Strategy

### Priority 1: High Risk Tests (Must Execute)

**Test Suite: Business Logic Correctness**

1. **Tier Limit Validation (BUS-001):**
   ```typescript
   // Verify FREE tier limits match database schema
   expect(TIER_LIMITS.FREE.accounts).toBe(3);
   expect(TIER_LIMITS.FREE.transactionsPerMonth).toBe(50);
   expect(TIER_LIMITS.FREE.receiptsPerMonth).toBe(10);

   // Cross-reference with migration file
   // supabase/migrations/20250109000001_create_financial_schema.sql
   ```

2. **Hardcoded Value Audit (TECH-001):**
   ```bash
   # Search for magic numbers
   grep -rn "50.*1024.*1024\|0\.90\|0\.95\|0\.70" src/ --exclude-dir=config
   # Expected: No matches (all use constants)
   ```

3. **Tier Limit E2E Enforcement (BUS-001):**
   ```typescript
   // Test free user hits limit
   test('free user cannot create 4th bank account', async ({ page }) => {
     // Setup: 3 existing accounts
     // Attempt: Create 4th account
     // Verify: Error message shows "maximum of 3 bank accounts"
   });
   ```

**Time:** ~30 minutes

### Priority 2: Medium Risk Tests (Should Execute)

**Test Suite: Algorithm Correctness**

1. **Reconciliation Weights Sum (TECH-002):**
   ```typescript
   const sum = RECONCILIATION_WEIGHTS.dateMatch +
               RECONCILIATION_WEIGHTS.amountMatch +
               RECONCILIATION_WEIGHTS.merchantMatch;
   expect(sum).toBe(1.0);
   ```

2. **OCR Threshold Validation (BUS-002):**
   ```typescript
   expect(OCR_ACCOUNT_NUMBER_THRESHOLD).toBe(0.90);
   expect(OCR_RECEIPT_DATA_THRESHOLD).toBe(0.90);
   ```

3. **Documentation Completeness (OPS-001):**
   ```bash
   # Verify all constants have JSDoc
   # Manual review or automated script
   ```

**Time:** ~15 minutes

### Priority 3: Low Risk Tests (Nice to Have)

1. **Type Safety (TECH-003):**
   ```typescript
   // TypeScript compilation validates
   const tier: TierName = 'FREE'; // ✅ Valid
   // const tier: TierName = 'BASIC'; // ❌ Compile error
   ```

2. **Bundle Size (PERF-001):**
   ```bash
   npm run build
   # Verify output size is reasonable
   ```

**Time:** ~10 minutes

**Total Testing Time:** ~55 minutes

---

## Risk Acceptance Criteria

### Must Fix Before Production

1. **BUS-001:** Verify tier limits match database schema (automated test)
2. **TECH-001:** Audit codebase for hardcoded values (clean up any found)
3. **TECH-002:** Validate reconciliation weights sum to 1.0 (unit test)

### Can Deploy with Mitigation (Monitoring)

4. **BUS-002:** OCR thresholds (collect metrics post-launch, adjust if needed)
5. **OPS-001:** Documentation completeness (ongoing improvement)

### Accepted Risks (Low Priority)

6. **TECH-003:** Type safety gaps (TypeScript + linting sufficient)
7. **PERF-001:** Bundle size (tree-shaking handles optimization)

---

## Monitoring Requirements

### Post-Deployment Monitoring (First 2 Weeks)

1. **Tier Limit Hit Rate:**
   ```sql
   -- Track how often free users hit limits
   SELECT
     COUNT(*) as limit_hits,
     limit_type -- 'accounts', 'transactions', 'receipts'
   FROM tier_limit_events
   WHERE user_tier = 'user' AND created_at > NOW() - INTERVAL '7 days'
   GROUP BY limit_type;
   ```
   - **Alert:** If hit rate > 50% of free users → Limits too restrictive
   - **Action:** Consider tier limit adjustment story

2. **OCR Confidence Distribution:**
   ```sql
   -- Track OCR confidence scores
   SELECT
     AVG(confidence_score) as avg_confidence,
     MIN(confidence_score) as min_confidence,
     COUNT(CASE WHEN confidence_score < 0.90 THEN 1 END) as below_threshold
   FROM receipts
   WHERE created_at > NOW() - INTERVAL '7 days';
   ```
   - **Alert:** If >30% below threshold → Threshold too high
   - **Action:** Collect manual review outcomes, adjust threshold

3. **Premium Conversion Rate:**
   - **Metric:** % of users who upgrade after hitting tier limit
   - **Target:** >10% conversion rate
   - **Alert:** If <5% → Tier limits not motivating upgrades

### Alerting Thresholds

- **Critical:** Tier limits in constants don't match database (weekly automated check)
- **Warning:** OCR threshold effectiveness <70% (manual review required)
- **Info:** Hardcoded values detected in code (CI/CD pipeline failure)

---

## Risk Review Triggers

This risk profile should be reviewed and updated when:

1. **Business Model Changes:** Tier limits or pricing adjusted
2. **OCR Provider Changes:** Confidence score calculation may differ
3. **Reconciliation Algorithm Updates:** Weight distribution may need rebalancing
4. **Regulatory Requirements:** File size/format restrictions may change
5. **User Feedback:** Indicates tier limits or thresholds are problematic
6. **Performance Issues:** Bundle size or constant import overhead detected

---

## Conclusion

Story 1.4 carries **MODERATE RISK (74/100)** due to the straightforward nature of configuration constants. No critical risks identified.

### Risk Summary

**High Risks (2):**
- BUS-001: Tier limits mismatch → Revenue impact
- TECH-001: Hardcoded values → Inconsistency

**Medium Risks (3):**
- TECH-002: Weight sum ≠ 1.0 → Algorithm errors
- BUS-002: OCR thresholds suboptimal → Poor UX
- OPS-001: Missing docs → Misuse

**Low Risks (2):**
- TECH-003: Type safety gaps → Runtime errors (unlikely)
- PERF-001: Bundle size → Minimal impact

### Recommended Approach

1. **Pre-Deployment (Must Do):**
   - Execute all P0/P1 tests from test design document (18 tests, ~50 mins)
   - Audit codebase for hardcoded values (TECH-001)
   - Add unit tests for tier limits and weight sum

2. **Post-Deployment (Should Do):**
   - Monitor OCR confidence distribution for 2 weeks
   - Track tier limit hit rate and premium conversions
   - Collect user feedback on threshold appropriateness

3. **Future Optimization (Nice to Have):**
   - A/B test OCR thresholds for optimal automation rate
   - Experiment with tier limit values to maximize conversions
   - Add runtime immutability with Object.freeze

### Gate Recommendation

**Initial Assessment:** ✅ **PASS** - Low-risk story with manageable verification tasks

**Path to Production:**
- Execute test suite (all 18 tests must pass)
- Clean up any hardcoded values found in audit
- Document any assumptions about thresholds for future optimization

Once testing complete, gate status remains **PASS** (no critical/high risks require mitigation beyond standard testing).

---

## Risk Summary for Quality Gate

```yaml
risk_summary:
  totals:
    critical: 0
    high: 2
    medium: 3
    low: 2
  highest:
    id: BUS-001
    score: 6
    title: 'Incorrect tier limits harm revenue model'
  recommendations:
    must_fix:
      - 'Add unit test validating tier limits match database schema'
      - 'Audit codebase for hardcoded magic numbers and replace with constants'
      - 'Verify reconciliation weights sum to 1.0'
    monitor:
      - 'Track OCR confidence distribution post-launch to validate thresholds'
      - 'Monitor tier limit hit rate and premium conversion rate'
      - 'Collect user feedback on threshold appropriateness'
```

---

**Test Design Reference:** [docs/qa/assessments/1.4-verify-config-constants-test-design-20250110.md](../assessments/1.4-verify-config-constants-test-design-20250110.md)
