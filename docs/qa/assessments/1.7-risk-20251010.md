# Risk Profile: Story 1.7 - Implement User Tier System Integration

**Date:** 2025-10-10
**Reviewer:** Quinn (Test Architect)
**Story:** 1.7 - Implement User Tier System Integration

## Executive Summary

- **Total Risks Identified:** 6
- **Critical Risks:** 0
- **High Risks:** 1
- **Medium Risks:** 2
- **Low Risks:** 3
- **Overall Risk Score:** 74/100 (Moderate Risk)

**Key Concern:** Security risk from potential RLS policy bypass if client-side tier data is trusted without server validation. Requires strong enforcement pattern.

## Critical Risks Requiring Immediate Attention

### 1. SEC-001: RLS Policy Bypass via Client-Side Tier Manipulation

**Score: 6 (High Risk)**
**Probability:** Medium (2) - Developers might inadvertently trust client-side tier context without server validation
**Impact:** High (3) - Free users could bypass premium features, violating business model

**Risk Details:**
The story emphasizes "server-derived tier" data, but the AuthContext pattern could be misused if developers:
- Cache tier data client-side and rely on it for feature gating
- Implement tier checks only in UI without backend validation
- Use tier data from React Query cache for authorization decisions

**Affected Components:**
- `src/contexts/AuthContext.tsx` - Tier data exposure
- `src/lib/tierValidation.ts` - Client-side validation utilities
- `src/hooks/financial/useUserTier.ts` - Tier data fetching
- Bank account creation, transaction upload, receipt upload flows

**Mitigation:**
1. **Preventive Controls:**
   - Add clear documentation: "NEVER use client tier data for authorization"
   - Implement server-side tier validation in ALL API endpoints
   - Use Supabase RLS policies to enforce tier limits at database level
   - Add code review checklist item: "Verify tier enforcement is server-side"

2. **Detective Controls:**
   - Add integration tests verifying client tier manipulation doesn't bypass limits
   - Test scenario: Modify AuthContext tier to 'premium_user', verify limits still enforced
   - Monitor API logs for tier limit violations

3. **Specific Implementation Requirements:**
   ```typescript
   // CORRECT: Server validates tier via RLS
   const { data, error } = await supabase
     .from('bank_accounts')
     .insert({ user_id: userId, ...accountData });
   // RLS policy checks user_tiers.accounts_limit before insert

   // INCORRECT: Trusting client tier for authorization
   if (userTier.tier === 'premium_user') {
     await createAccount(); // ❌ Client data controls access
   }
   ```

4. **Testing Requirements:**
   - Security test: Attempt tier bypass via modified AuthContext
   - RLS test: Verify database rejects over-limit inserts regardless of client state
   - Integration test: Mock tier upgrade, verify cache invalidation and limit updates

**Residual Risk:** Low - If server-side enforcement is complete, client manipulation has no effect

**Owner:** Dev Team (with security review)
**Timeline:** Must address before Story 1.7 completion

---

## Risk Distribution

### By Category
- **Security:** 1 risk (1 high)
- **Technical:** 1 risk (1 medium)
- **Performance:** 1 risk (1 low)
- **Data:** 1 risk (1 low)
- **Business:** 1 risk (1 medium)
- **Operational:** 1 risk (1 low)

### By Component
- **Frontend (AuthContext, hooks, validation):** 4 risks
- **Backend (RLS, database triggers):** 2 risks
- **Integration (React Query, Supabase):** 3 risks

## Detailed Risk Register

| Risk ID  | Category    | Description                                    | Probability | Impact     | Score | Priority | Mitigation Owner |
|----------|-------------|------------------------------------------------|-------------|------------|-------|----------|------------------|
| SEC-001  | Security    | RLS Policy Bypass via Client Tier Manipulation | Medium (2)  | High (3)   | 6     | High     | Dev Team         |
| TECH-001 | Technical   | React Query Cache Invalidation Failures        | Medium (2)  | Medium (2) | 4     | Medium   | Dev Team         |
| BUS-001  | Business    | Free Tier Limit Enforcement Inconsistency      | Medium (2)  | Medium (2) | 4     | Medium   | Dev Team         |
| DATA-001 | Data        | Tier Data Integrity with Missing Trigger       | Low (1)     | High (3)   | 3     | Low      | Dev Team         |
| PERF-001 | Performance | N+1 Query Pattern in Tier Limit Checks         | High (3)    | Low (1)    | 3     | Low      | Dev Team         |
| OPS-001  | Operational | Missing Tier Upgrade Event Monitoring          | Medium (2)  | Low (1)    | 2     | Low      | DevOps           |

## Medium and Low Risks

### TECH-001: React Query Cache Invalidation Failures
**Score: 4 (Medium Risk)**

**Description:** Users may see stale tier data after upgrade due to 5-minute stale time in React Query cache.

**Mitigation:**
- Implement tier upgrade event listener that invalidates `['user-tier', userId]` cache
- Add manual cache invalidation in upgrade flow:
  ```typescript
  queryClient.invalidateQueries({ queryKey: ['user-tier', user.id] });
  ```
- Test scenario: Upgrade tier, verify UI updates within 1 second
- Document cache invalidation strategy in dev notes

**Testing Requirements:**
- Integration test: Simulate tier upgrade, verify cache refresh
- E2E test: Upgrade flow shows updated limits immediately

---

### BUS-001: Free Tier Limit Enforcement Inconsistency
**Score: 4 (Medium Risk)**

**Description:** Client-side and server-side tier limit checks may diverge, causing user frustration.

**Mitigation:**
- Use single source of truth: RLS policies define limits, client reads from same data
- Add validation helper that mirrors RLS logic:
  ```typescript
  // Client validation preview (not authorization)
  export function canCreateBankAccount(tier, currentCount) {
    return currentCount < tier.accounts_limit; // Matches RLS check
  }
  ```
- Server-side validation always wins; client validation is UX preview only
- Document: "Client validation prevents wasted API calls, server enforces security"

**Testing Requirements:**
- Consistency test: Verify client validation matches server rejection scenarios
- Edge case test: User at exact limit, verify both client and server agree

---

### DATA-001: Tier Data Integrity with Missing Trigger
**Score: 3 (Low Risk)**

**Description:** Edge cases (race conditions, failed transactions) could leave users without tier data.

**Mitigation:**
- Add defensive check in useUserTier hook:
  ```typescript
  if (!data) {
    // Fallback: Create missing tier record
    await supabase.rpc('ensure_user_tier', { user_id: userId });
  }
  ```
- Add database constraint: `ALTER TABLE user_tiers ADD CONSTRAINT unique_user CHECK ...`
- Monitor for users without tier records in observability dashboard

**Testing Requirements:**
- Test orphaned user scenario (manually delete tier record, verify recovery)
- Load test: Concurrent signups, verify all users get tier records

---

### PERF-001: N+1 Query Pattern in Tier Limit Checks
**Score: 3 (Low Risk)**

**Description:** Multiple tier fetches per user action could degrade performance.

**Mitigation:**
- React Query caching already mitigates (5-minute stale time)
- Use `enabled: !!user` flag to prevent unnecessary fetches
- Consider moving tier data into session claims (Supabase JWT) for zero-query access
- Monitor: Add metric for tier query frequency per user session

**Testing Requirements:**
- Performance test: Track number of tier queries during typical user flow
- Target: ≤1 tier query per 5-minute session

---

### OPS-001: Missing Tier Upgrade Event Monitoring
**Score: 2 (Low Risk)**

**Description:** No observability for tier changes and limit violations (analytics gap).

**Mitigation:**
- Add event logging for:
  - Tier upgrades (user_id, from_tier, to_tier, timestamp)
  - Limit violations (user_id, limit_type, attempted_count, timestamp)
- Use Supabase Edge Functions or database triggers to log events
- Create dashboard for tier metrics (upgrades/month, violation patterns)

**Testing Requirements:**
- Verify events are logged for upgrade scenarios
- Test dashboard displays tier analytics correctly

---

## Risk-Based Testing Strategy

### Priority 1: High Risk Tests (SEC-001)

**Test Scenarios:**

1. **Security Test: Client Tier Bypass Attempt**
   ```
   GIVEN a free user with modified AuthContext showing tier='premium_user'
   WHEN user attempts to create 4th bank account (over free limit)
   THEN server rejects request with "Account limit reached" error
   AND client validation correctly blocks UI action
   ```

2. **RLS Policy Test: Database-Level Enforcement**
   ```
   GIVEN user_tiers record shows accounts_limit=3
   WHEN direct SQL insert attempts to add 4th bank_account
   THEN RLS policy blocks insert
   AND returns appropriate error message
   ```

3. **Integration Test: End-to-End Limit Enforcement**
   ```
   GIVEN free user with 3 bank accounts
   WHEN user clicks "Add Bank Account" button
   THEN UI shows UpgradePrompt modal
   AND API call is never made (client-side prevention)
   AND if API call is forced, server rejects it
   ```

### Priority 2: Medium Risk Tests (TECH-001, BUS-001)

**Cache Invalidation Tests:**
```
GIVEN user with free tier cached in React Query
WHEN admin upgrades user to premium via backend
AND tier upgrade event fires
THEN AuthContext.userTier updates within 1 second
AND UI shows "Unlimited" limits immediately
```

**Consistency Tests:**
```
GIVEN user at exact tier limit (e.g., 3/3 accounts)
WHEN user attempts to create account
THEN client validation shows "limit reached" message
AND server returns 403 with same reasoning
AND both use identical limit value (3)
```

### Priority 3: Low Risk Tests (DATA-001, PERF-001, OPS-001)

**Data Integrity Tests:**
- Test user signup without tier record (simulate trigger failure)
- Verify fallback tier creation mechanism

**Performance Tests:**
- Monitor tier query count during 10-minute user session
- Target: ≤3 queries (initial load + 2 cache refreshes)

**Observability Tests:**
- Verify tier upgrade events appear in logs
- Test limit violation tracking dashboard

---

## Risk Acceptance Criteria

### Must Fix Before Production
- ✅ **SEC-001:** Server-side tier enforcement implemented and tested
- ✅ **TECH-001:** Cache invalidation on tier upgrade working
- ✅ **BUS-001:** Client/server validation consistency verified

### Can Deploy with Mitigation
- ⚠️ **DATA-001:** Fallback tier creation logic in place
- ⚠️ **PERF-001:** React Query caching configured correctly

### Accepted Risks (Can Address Post-Launch)
- ℹ️ **OPS-001:** Tier analytics dashboard (nice-to-have, not blocking)

---

## Monitoring Requirements

**Post-Deployment Monitoring:**

1. **Security Monitoring (SEC-001):**
   - Alert on tier limit violations with status=403
   - Track API calls to tier-gated endpoints by user tier
   - Monitor for unusual patterns (free users hitting premium features)

2. **Performance Monitoring (PERF-001):**
   - Track `user_tiers` query latency (p95, p99)
   - Monitor React Query cache hit rate for tier data
   - Alert if tier queries exceed 10/minute per user

3. **Business Metrics (BUS-001):**
   - Count of users hitting free tier limits (upgrade funnel metric)
   - Conversion rate: limit hit → premium upgrade
   - Track which limit (accounts/transactions/receipts) triggers most upgrades

4. **Data Integrity (DATA-001):**
   - Daily check: users without tier records (should be 0)
   - Alert if user_tiers count < auth.users count

---

## Risk Review Triggers

**Re-assess risk profile when:**

1. ✅ **Architecture Changes:**
   - Migration from React Query to different state management
   - Changes to RLS policy structure

2. ✅ **New Integrations:**
   - Payment provider integration for tier upgrades
   - Third-party tier management system

3. ✅ **Security Events:**
   - Discovered RLS policy bypass vulnerability
   - User reports bypassing tier limits

4. ✅ **Performance Issues:**
   - Tier query latency exceeds 100ms
   - Cache invalidation causing UI lag

5. ✅ **Business Changes:**
   - New tier introduced (e.g., "Enterprise")
   - Tier limit values modified

---

## Recommendations Summary

### Immediate Actions (Before Story Completion)
1. **Implement server-side tier validation in all tier-gated API endpoints**
2. **Add integration tests for tier bypass attempts (SEC-001)**
3. **Document tier enforcement pattern clearly for dev team**
4. **Implement cache invalidation on tier upgrade events (TECH-001)**

### Phase 2 (Post-MVP)
1. Add tier upgrade event monitoring dashboard (OPS-001)
2. Optimize tier query performance if metrics show issues (PERF-001)
3. Implement tier analytics for business intelligence

### Code Review Checklist
- [ ] Server-side tier validation present in all tier-gated endpoints
- [ ] RLS policies enforce tier limits at database level
- [ ] Client-side validation matches server-side logic
- [ ] Cache invalidation triggers on tier changes
- [ ] Tests cover tier bypass attempts
- [ ] Error messages are user-friendly and consistent

---

## Quality Gate Recommendation

**Based on risk analysis:**

- **If SEC-001 mitigated (server-side enforcement):** PASS
- **If SEC-001 not addressed:** CONCERNS (high security risk)
- **If multiple medium risks unaddressed:** CONCERNS

**Current Assessment:** Gate decision pending implementation review.

---

**Risk Profile Location:** `docs/qa/assessments/1.7-risk-20251010.md`
