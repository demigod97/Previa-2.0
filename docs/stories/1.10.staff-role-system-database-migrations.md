# Story 1.10: Staff Role System + Database Migrations

## Status
Draft

## Epic
Epic 1: Foundation & Core Services

## Story
**As a** platform administrator,
**I want** a separate staff role system (team, super_admin) independent from user tiers,
**so that** staff can manage the platform without exposing admin features to regular users.

## Context Source
- Source Document: User request + Current schema analysis
- Enhancement Type: New feature (staff role system)
- Existing System Impact: Adds parallel role system to user_tiers

## Acceptance Criteria

### AC1: Staff Roles Table Structure
- [ ] Create `staff_roles` table in public schema
- [ ] Support two role types: 'team', 'super_admin'
- [ ] Roles are separate from user_tiers (a user can have both a tier and a staff role)
- [ ] Table includes role assignment metadata (assigned_by, assigned_at)
- [ ] Constraints prevent regular users from being assigned staff roles accidentally

### AC2: Make Specific User Super Admin
- [ ] User `demi@coralshades.ai` (ID: 273fb674-b87b-4604-89d5-41ab0b46d356) assigned 'super_admin' role
- [ ] Assignment happens via migration seed data
- [ ] Role is immediately active upon migration
- [ ] Verification query confirms role assignment

### AC3: RLS Policies for Staff Tables
- [ ] `staff_roles` table has RLS enabled
- [ ] Only super_admin users can read staff_roles table
- [ ] Only super_admin users can assign/revoke staff roles
- [ ] Regular users cannot see staff role assignments
- [ ] Team members can read but not modify staff_roles

### AC4: Helper Functions for Role Checks
- [ ] Create `is_super_admin(user_id UUID)` Postgres function
- [ ] Create `is_staff_member(user_id UUID)` Postgres function (returns true for team OR super_admin)
- [ ] Create `get_user_staff_role(user_id UUID)` function (returns role or NULL)
- [ ] Functions are callable from application code and RLS policies

### AC5: Frontend Should Not Show Staff Features (Yet)
- [ ] No UI changes in this story
- [ ] Staff role system exists in database only
- [ ] Story 1.11 will add admin UI for code management
- [ ] Regular users see no indication of staff roles

## Dev Technical Guidance

### Existing System Context
**Database Schema:**
```sql
-- Already exists
auth.users (Supabase managed)
public.profiles (references auth.users)
public.user_tiers (tier: 'user' | 'premium_user') -- Payment/subscription tiers

-- To be created
public.staff_roles (role: 'team' | 'super_admin') -- Platform admin roles
```

**Key Separation of Concerns:**
- `user_tiers`: Business tier (free vs premium) - visible to users
- `staff_roles`: Platform admin level - invisible to regular users
- A user can have both (e.g., super_admin with premium_user tier for testing)

### Integration Approach
**Database Schema Design:**

```sql
-- Staff roles table
CREATE TABLE public.staff_roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('team', 'super_admin')),
  assigned_by UUID REFERENCES auth.users(id),
  assigned_at TIMESTAMPTZ DEFAULT NOW(),
  notes TEXT
);

-- Helper functions
CREATE OR REPLACE FUNCTION public.is_super_admin(user_id UUID)
RETURNS BOOLEAN AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.staff_roles
    WHERE staff_roles.user_id = is_super_admin.user_id
    AND role = 'super_admin'
  );
$$ LANGUAGE SQL STABLE SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.is_staff_member(user_id UUID)
RETURNS BOOLEAN AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.staff_roles
    WHERE staff_roles.user_id = is_staff_member.user_id
    AND role IN ('team', 'super_admin')
  );
$$ LANGUAGE SQL STABLE SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.get_user_staff_role(user_id UUID)
RETURNS TEXT AS $$
  SELECT role FROM public.staff_roles
  WHERE staff_roles.user_id = get_user_staff_role.user_id;
$$ LANGUAGE SQL STABLE SECURITY DEFINER;
```

### Technical Constraints
- **RLS Security:**
  - Must use SECURITY DEFINER for helper functions to bypass RLS
  - RLS policies must use these helper functions for consistency
  - Prevent privilege escalation (users can't assign themselves roles)

- **Migration Safety:**
  - Check if user exists before assigning role
  - Handle case where user might already have a role
  - Use UPSERT pattern (ON CONFLICT DO UPDATE)

### File Locations
```
supabase/
  migrations/
    YYYYMMDDHHMMSS_create_staff_roles_system.sql    # New migration
    YYYYMMDDHHMMSS_assign_initial_super_admin.sql   # New migration
src/
  types/
    staff.ts                                          # New: StaffRole type definitions
  hooks/
    staff/
      useStaffRole.ts                                 # New: Hook for checking staff role (for future use)
```

### Testing Requirements
**Database Tests:**
- Staff role assignment and retrieval
- Helper function accuracy
- RLS policy enforcement
- Privilege escalation prevention

**Integration Tests:**
- Verify super_admin user can query staff_roles
- Verify regular user cannot query staff_roles
- Verify role check functions work correctly

## Tasks / Subtasks

### Task 1: Create Staff Roles Table Migration (AC1)
- [ ] Create migration: `supabase/migrations/YYYYMMDDHHMMSS_create_staff_roles_system.sql`
- [ ] Define `staff_roles` table schema:
  ```sql
  CREATE TABLE IF NOT EXISTS public.staff_roles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID UNIQUE NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role TEXT NOT NULL CHECK (role IN ('team', 'super_admin')),
    assigned_by UUID REFERENCES auth.users(id),
    assigned_at TIMESTAMPTZ DEFAULT NOW(),
    notes TEXT,
    CONSTRAINT unique_user_role UNIQUE (user_id)
  );

  -- Indexes for performance
  CREATE INDEX idx_staff_roles_user ON public.staff_roles(user_id);
  CREATE INDEX idx_staff_roles_role ON public.staff_roles(role);

  -- Enable RLS
  ALTER TABLE public.staff_roles ENABLE ROW LEVEL SECURITY;
  ```
- [ ] Test migration locally: `supabase db reset`
- [ ] Verify table creation and constraints

### Task 2: Create Helper Functions (AC4)
- [ ] Add to same migration file: Helper functions
  ```sql
  -- Check if user is super admin
  CREATE OR REPLACE FUNCTION public.is_super_admin(check_user_id UUID)
  RETURNS BOOLEAN AS $$
    SELECT EXISTS (
      SELECT 1 FROM public.staff_roles
      WHERE user_id = check_user_id
      AND role = 'super_admin'
    );
  $$ LANGUAGE SQL STABLE SECURITY DEFINER;

  -- Check if user is any staff member
  CREATE OR REPLACE FUNCTION public.is_staff_member(check_user_id UUID)
  RETURNS BOOLEAN AS $$
    SELECT EXISTS (
      SELECT 1 FROM public.staff_roles
      WHERE user_id = check_user_id
      AND role IN ('team', 'super_admin')
    );
  $$ LANGUAGE SQL STABLE SECURITY DEFINER;

  -- Get user's staff role
  CREATE OR REPLACE FUNCTION public.get_user_staff_role(check_user_id UUID)
  RETURNS TEXT AS $$
    SELECT role FROM public.staff_roles
    WHERE user_id = check_user_id
    LIMIT 1;
  $$ LANGUAGE SQL STABLE SECURITY DEFINER;

  -- Grant execute permissions
  GRANT EXECUTE ON FUNCTION public.is_super_admin(UUID) TO authenticated;
  GRANT EXECUTE ON FUNCTION public.is_staff_member(UUID) TO authenticated;
  GRANT EXECUTE ON FUNCTION public.get_user_staff_role(UUID) TO authenticated;
  ```
- [ ] Test each function with SQL queries
- [ ] Verify SECURITY DEFINER allows RLS bypass

### Task 3: Create RLS Policies (AC3)
- [ ] Add to same migration file: RLS policies
  ```sql
  -- Super admins can see all staff roles
  CREATE POLICY "Super admins can view all staff roles" ON public.staff_roles
    FOR SELECT TO authenticated
    USING (public.is_super_admin(auth.uid()));

  -- Super admins can insert staff roles
  CREATE POLICY "Super admins can assign staff roles" ON public.staff_roles
    FOR INSERT TO authenticated
    WITH CHECK (public.is_super_admin(auth.uid()));

  -- Super admins can update staff roles
  CREATE POLICY "Super admins can modify staff roles" ON public.staff_roles
    FOR UPDATE TO authenticated
    USING (public.is_super_admin(auth.uid()));

  -- Super admins can delete staff roles
  CREATE POLICY "Super admins can revoke staff roles" ON public.staff_roles
    FOR DELETE TO authenticated
    USING (public.is_super_admin(auth.uid()));

  -- Users can view their own staff role (for UI checks)
  CREATE POLICY "Users can view own staff role" ON public.staff_roles
    FOR SELECT TO authenticated
    USING (user_id = auth.uid());
  ```
- [ ] Test policies with different user contexts
- [ ] Verify regular user cannot see other staff roles
- [ ] Verify user can see their own role

### Task 4: Update signup_codes RLS Policies (AC3)
- [ ] Create migration: `supabase/migrations/YYYYMMDDHHMMSS_update_signup_codes_rls.sql`
- [ ] Replace temporary policy with staff-only policies:
  ```sql
  -- Drop temporary policy from Story 1.9
  DROP POLICY IF EXISTS "Allow authenticated to verify codes" ON public.signup_codes;

  -- Staff can manage signup codes
  CREATE POLICY "Staff can view signup codes" ON public.signup_codes
    FOR SELECT TO authenticated
    USING (public.is_staff_member(auth.uid()));

  CREATE POLICY "Super admins can insert signup codes" ON public.signup_codes
    FOR INSERT TO authenticated
    WITH CHECK (public.is_super_admin(auth.uid()));

  CREATE POLICY "Super admins can update signup codes" ON public.signup_codes
    FOR UPDATE TO authenticated
    USING (public.is_super_admin(auth.uid()));

  CREATE POLICY "Super admins can delete signup codes" ON public.signup_codes
    FOR DELETE TO authenticated
    USING (public.is_super_admin(auth.uid()));

  -- Public can verify codes (for signup process)
  -- Use a special RPC function for this instead of direct SELECT
  ```
- [ ] Create RPC function for public code verification:
  ```sql
  CREATE OR REPLACE FUNCTION public.verify_signup_code(check_code TEXT)
  RETURNS TABLE(valid BOOLEAN, reason TEXT) AS $$
  BEGIN
    -- Check code exists and is active
    IF NOT EXISTS (
      SELECT 1 FROM public.signup_codes
      WHERE code = check_code AND is_active = true
    ) THEN
      RETURN QUERY SELECT FALSE, 'Invalid or inactive code'::TEXT;
      RETURN;
    END IF;

    -- Check expiry
    IF EXISTS (
      SELECT 1 FROM public.signup_codes
      WHERE code = check_code AND expiry_date IS NOT NULL AND expiry_date < NOW()
    ) THEN
      RETURN QUERY SELECT FALSE, 'Code has expired'::TEXT;
      RETURN;
    END IF;

    -- Check usage limit
    IF EXISTS (
      SELECT 1 FROM public.signup_codes
      WHERE code = check_code 
      AND use_limit IS NOT NULL 
      AND used_count >= use_limit
    ) THEN
      RETURN QUERY SELECT FALSE, 'Code usage limit reached'::TEXT;
      RETURN;
    END IF;

    -- Code is valid
    RETURN QUERY SELECT TRUE, 'Code is valid'::TEXT;
  END;
  $$ LANGUAGE plpgsql SECURITY DEFINER;

  GRANT EXECUTE ON FUNCTION public.verify_signup_code(TEXT) TO anon;
  GRANT EXECUTE ON FUNCTION public.verify_signup_code(TEXT) TO authenticated;
  ```
- [ ] Test RPC function with valid/invalid codes
- [ ] Verify public access to RPC but not to table

### Task 5: Assign Initial Super Admin (AC2)
- [ ] Create migration: `supabase/migrations/YYYYMMDDHHMMSS_assign_initial_super_admin.sql`
- [ ] Assign demi@coralshades.ai as super_admin:
  ```sql
  -- Verify user exists first
  DO $$
  BEGIN
    IF EXISTS (SELECT 1 FROM auth.users WHERE id = '273fb674-b87b-4604-89d5-41ab0b46d356'::uuid) THEN
      -- Use UPSERT pattern in case role already exists
      INSERT INTO public.staff_roles (user_id, role, notes)
      VALUES (
        '273fb674-b87b-4604-89d5-41ab0b46d356'::uuid,
        'super_admin',
        'Initial super admin - assigned via migration'
      )
      ON CONFLICT (user_id) 
      DO UPDATE SET 
        role = 'super_admin',
        notes = 'Initial super admin - assigned via migration',
        assigned_at = NOW();
      
      RAISE NOTICE 'Super admin role assigned to user 273fb674-b87b-4604-89d5-41ab0b46d356';
    ELSE
      RAISE WARNING 'User 273fb674-b87b-4604-89d5-41ab0b46d356 not found - skipping super admin assignment';
    END IF;
  END $$;
  ```
- [ ] Test migration locally
- [ ] Verify role assignment with query:
  ```sql
  SELECT u.email, sr.role, sr.assigned_at 
  FROM auth.users u
  JOIN public.staff_roles sr ON u.id = sr.user_id
  WHERE u.id = '273fb674-b87b-4604-89d5-41ab0b46d356'::uuid;
  ```

### Task 6: Create TypeScript Type Definitions (AC5)
- [ ] Create `src/types/staff.ts`:
  ```typescript
  export type StaffRole = 'team' | 'super_admin';

  export interface StaffRoleData {
    id: string;
    user_id: string;
    role: StaffRole;
    assigned_by: string | null;
    assigned_at: string;
    notes: string | null;
  }

  export interface StaffRoleCheck {
    isSuperAdmin: boolean;
    isStaffMember: boolean;
    role: StaffRole | null;
  }
  ```
- [ ] Update `src/integrations/supabase/types.ts`:
  - Add `staff_roles` table type definition
  - Ensure type generation includes new table

### Task 7: Create useStaffRole Hook (AC5)
- [ ] Create `src/hooks/staff/useStaffRole.ts`:
  ```typescript
  import { useEffect, useState } from 'react';
  import { supabase } from '@/integrations/supabase/client';
  import { useAuth } from '@/contexts/AuthContext';
  import { StaffRoleCheck } from '@/types/staff';

  export const useStaffRole = () => {
    const { user } = useAuth();
    const [staffRole, setStaffRole] = useState<StaffRoleCheck>({
      isSuperAdmin: false,
      isStaffMember: false,
      role: null
    });
    const [loading, setLoading] = useState(true);

    useEffect(() => {
      const fetchStaffRole = async () => {
        if (!user) {
          setStaffRole({ isSuperAdmin: false, isStaffMember: false, role: null });
          setLoading(false);
          return;
        }

        try {
          // Query staff_roles table (will only work if user has permission or is checking self)
          const { data, error } = await supabase
            .from('staff_roles')
            .select('role')
            .eq('user_id', user.id)
            .maybeSingle();

          if (error) {
            console.error('Error fetching staff role:', error);
            setStaffRole({ isSuperAdmin: false, isStaffMember: false, role: null });
          } else if (data) {
            setStaffRole({
              isSuperAdmin: data.role === 'super_admin',
              isStaffMember: true,
              role: data.role
            });
          } else {
            setStaffRole({ isSuperAdmin: false, isStaffMember: false, role: null });
          }
        } catch (error) {
          console.error('Error in useStaffRole:', error);
          setStaffRole({ isSuperAdmin: false, isStaffMember: false, role: null });
        } finally {
          setLoading(false);
        }
      };

      fetchStaffRole();
    }, [user]);

    return { ...staffRole, loading };
  };
  ```
- [ ] Test hook with super_admin user
- [ ] Test hook with regular user
- [ ] Test hook with no user (logged out)

### Task 8: Apply Migrations to Supabase Cloud (AC1, AC2, AC3)
- [ ] Run locally first: `supabase db reset` (to test from scratch)
- [ ] Verify all migrations apply successfully
- [ ] Test all helper functions
- [ ] Test all RLS policies
- [ ] Push to Supabase cloud: `supabase db push`
- [ ] Verify in Supabase dashboard: Database > staff_roles table exists
- [ ] Verify super_admin role assigned to demi@coralshades.ai
- [ ] Run verification query in SQL Editor:
  ```sql
  -- Verify super admin assignment
  SELECT 
    u.email,
    u.id,
    sr.role,
    sr.assigned_at,
    sr.notes,
    public.is_super_admin(u.id) as is_super_admin_check,
    public.is_staff_member(u.id) as is_staff_member_check
  FROM auth.users u
  LEFT JOIN public.staff_roles sr ON u.id = sr.user_id
  WHERE u.email = 'demi@coralshades.ai';
  ```

### Task 9: Integration Testing (AC1-AC5)
- [ ] Test: Super admin can query staff_roles table
- [ ] Test: Regular user cannot query staff_roles table (except own role)
- [ ] Test: Helper functions return correct values
- [ ] Test: RLS policies prevent unauthorized access
- [ ] Test: verify_signup_code RPC works for anonymous users
- [ ] Test: Regular users cannot call verify_signup_code to see all codes
- [ ] Write automated tests for:
  - Staff role assignment
  - Helper function accuracy
  - RLS policy enforcement
  - Hook behavior with different user types

### Task 10: Documentation (AC5)
- [ ] Document staff role system in `docs/architecture/7-security-rls-deterministic-rules.md`
- [ ] Add section explaining staff_roles vs user_tiers separation
- [ ] Document helper functions and their usage
- [ ] Document RLS policies for staff tables
- [ ] Add examples of how to check staff roles in components (for Story 1.11)

## Risk Assessment

### Implementation Risks
- **Primary Risk**: Privilege escalation - users might try to assign themselves staff roles
- **Mitigation**: RLS policies only allow super_admins to modify staff_roles, helper functions use SECURITY DEFINER
- **Verification**: Security audit of RLS policies and helper functions

- **Secondary Risk**: Circular dependency - super_admin policy checks require super_admin to exist
- **Mitigation**: Initial super_admin assigned via migration (bypasses RLS)
- **Verification**: Verify first super_admin can assign additional admins

### Rollback Plan
- Drop staff_roles table
- Drop helper functions
- Revert signup_codes RLS policies to temporary policy
- No impact on existing users or user_tiers

### Safety Checks
- [ ] Existing authentication and user_tiers functionality unaffected
- [ ] No UI changes (staff features hidden until Story 1.11)
- [ ] Migrations are reversible
- [ ] Super admin can be verified immediately after migration

## Definition of Done
- [ ] All acceptance criteria met and tested
- [ ] All migrations applied to Supabase cloud successfully
- [ ] Super admin role verified for demi@coralshades.ai
- [ ] Helper functions work correctly
- [ ] RLS policies prevent unauthorized access
- [ ] Integration tests pass for all scenarios
- [ ] Code review completed
- [ ] Security review of RLS policies and helper functions
- [ ] Documentation updated in architecture docs
- [ ] No UI changes (as specified in AC5)

## Notes
- **No UI Yet**: This story focuses on database and security infrastructure only
- **Story 1.11**: Will build admin UI for signup code management using these staff roles
- **Future Expansion**: Additional staff roles (e.g., 'support', 'analyst') can be added easily
- **User Tiers**: Staff roles are completely separate from user_tiers - a super_admin can also be premium_user

