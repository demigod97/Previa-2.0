# Story 2.2: Bank Statement Upload & OCR Trigger

## Status: Approved

## Story

As a **new user completing the onboarding flow**,  
I want **to upload my first bank statement (PDF or CSV) and see it being processed**,  
So that **Previa can extract my account details and transactions automatically**.

## Acceptance Criteria

**AC1: Upload Interface**
- Onboarding step 2 displays "Upload Your Bank Statement" title
- Drag-and-drop zone for file upload (PDF or CSV)
- Click-to-browse file picker as alternative
- File type validation: only .pdf, .csv allowed
- File size validation: max 50MB
- Preview of selected file (name, size, type)
- "Continue" button disabled until valid file uploaded

**AC2: File Upload to Supabase Storage**
- Selected file uploaded to `bank-statements` bucket in Supabase Storage
- File path format: `{user_id}/{timestamp}_{filename}`
- Upload progress indicator (percentage or spinner)
- Error handling for upload failures (network, storage quota)
- Success message on upload complete

**AC3: Database Record Creation**
- Create row in `bank_statements` table with:
  - `user_id`, `file_path`, `processing_status: 'pending'`
  - `uploaded_at` timestamp
- Return `bank_statement_id` (UUID)

**AC4: Trigger OCR Processing**
- Call Edge Function `process-document` with:
  - `document_id` (bank_statement_id)
  - `user_id`
  - `document_type: 'bank_statement'`
  - `file_path`, `storage_bucket`
- Edge Function triggers n8n workflow via webhook
- Update `processing_status` to `'processing'` in database

**AC5: Processing Status Display**
- Display processing status UI:
  - "Processing your statement..." message
  - Indeterminate progress bar or spinner
  - Estimated time: "This usually takes 5-10 seconds"
- Poll database every 2 seconds for status updates
- Redirect to step 3 (account confirmation) when status = `'completed'`
- Show error message if status = `'failed'` with retry option

**AC6: Gamification Points**
- Award 5 points for uploading first bank statement
- Record in `point_transactions` table with reason: "First bank statement uploaded"
- Update `total_points` in `gamification_profiles`
- No UI display yet (backend only)

## Tasks / Subtasks

- [x] **Task 1: Create Upload Interface Component** (AC: 1)
  - [x] 1.1: Create `src/pages/onboarding/BankStatementUpload.tsx`
  - [x] 1.2: Implement drag-and-drop zone using react-dropzone
  - [x] 1.3: Add file type validation (.pdf, .csv only)
  - [x] 1.4: Add file size validation (max 50MB)
  - [x] 1.5: Display file preview (name, size, icon)
  - [x] 1.6: Add "Continue" button (disabled until valid file)
  - [x] 1.7: Style with Previa design system (cream bg, charcoal text)

- [x] **Task 2: Implement File Upload to Supabase Storage** (AC: 2)
  - [x] 2.1: Create `src/services/storageService.ts`
  - [x] 2.2: Implement `uploadBankStatement(file, userId)` function
  - [x] 2.3: Upload to `bank-statements` bucket with path `{userId}/{timestamp}_{filename}`
  - [x] 2.4: Show upload progress using Supabase Storage `onProgress` callback
  - [x] 2.5: Handle upload errors (network, quota exceeded, permissions)
  - [x] 2.6: Return file path on success

- [x] **Task 3: Create Database Record** (AC: 3)
  - [x] 3.1: After upload success, insert row in `bank_statements` table
  - [x] 3.2: Set fields: `user_id`, `file_path`, `processing_status: 'pending'`
  - [x] 3.3: Capture returned `id` as `bank_statement_id`
  - [x] 3.4: Handle database insert errors

- [x] **Task 4: Trigger OCR Processing** (AC: 4)
  - [x] 4.1: Create `src/services/ocrService.ts`
  - [x] 4.2: Implement `triggerBankStatementProcessing(documentId, userId, filePath)`
  - [x] 4.3: Call Supabase Edge Function `process-document` via fetch/axios
  - [x] 4.4: Pass payload: `{ document_id, user_id, document_type: 'bank_statement', file_path, storage_bucket: 'bank-statements' }`
  - [x] 4.5: Handle Edge Function errors (4xx, 5xx responses)
  - [x] 4.6: Update UI based on response (202 Accepted = processing started)

- [x] **Task 5: Processing Status Polling** (AC: 5)
  - [x] 5.1: Create `src/hooks/useProcessingStatus.ts` hook
  - [x] 5.2: Use React Query to poll `bank_statements` table for status
  - [x] 5.3: Poll every 2 seconds while `processing_status === 'processing'`
  - [x] 5.4: Stop polling when status is `'completed'` or `'failed'`
  - [x] 5.5: Display processing UI (spinner, message, estimated time)
  - [x] 5.6: Redirect to `/onboarding/confirm-account` on completion
  - [x] 5.7: Show error message with "Retry" button on failure

- [ ] **Task 6: Gamification Points Award** (AC: 6)
  - [ ] 6.1: Update `src/services/gamificationService.ts`
  - [ ] 6.2: Add `awardPoints(userId, points, reason)` function
  - [ ] 6.3: On upload success, call `awardPoints(userId, 5, 'First bank statement uploaded')`
  - [ ] 6.4: Insert row in `point_transactions` table
  - [ ] 6.5: Update `total_points` in `gamification_profiles` (increment by 5)
  - [ ] 6.6: Handle errors gracefully (don't block upload flow)

- [ ] **Task 7: Testing** (AC: 1, 2, 3, 4, 5, 6)
  - [ ] 7.1: Unit test file validation (type, size)
  - [ ] 7.2: Unit test upload progress display
  - [ ] 7.3: Integration test upload to Supabase Storage
  - [ ] 7.4: Integration test database record creation
  - [ ] 7.5: Integration test Edge Function call
  - [ ] 7.6: Integration test status polling and redirect
  - [ ] 7.7: Integration test gamification points award
  - [ ] 7.8: E2E test: upload file → process → redirect to step 3

## Dev Notes

### Previous Story Insights

**From Story 2.1 (Welcome & Authentication):**
- AuthContext provides current user session
- `user.id` available for file path and database records
- Toast notifications used for success/error messages

**From Story 1.6 (Build Design System):**
- Previa colors and fonts available via Tailwind
- Button, Input, Card components from shadcn/ui

### Architecture Context

**File Storage (from architecture/backend-architecture.md):**
- Supabase Storage with buckets: `bank-statements`, `receipts`
- RLS policies enforce user can only access their own files
- Signed URLs generated for n8n to access files
- Max file size: 50MB per file

**Edge Functions (from specifications/n8n-integration-patterns.md):**
- Edge Function: `process-document` at `https://{project}.supabase.co/functions/v1/process-document`
- Accepts POST with JSON payload
- Returns 202 Accepted if processing started
- Triggers n8n Extract Text workflow via webhook

**Frontend Structure (from architecture/unified-project-structure.md):**
- Pages: `src/pages/onboarding/BankStatementUpload.tsx`
- Services: `src/services/storageService.ts`, `src/services/ocrService.ts`
- Hooks: `src/hooks/useProcessingStatus.ts`

### Data Models

**bank_statements Table (from architecture/database-schema.md):**

```sql
CREATE TABLE bank_statements (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  file_path VARCHAR(500) NOT NULL,
  processing_status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'processing', 'completed', 'failed'
  uploaded_at TIMESTAMPTZ DEFAULT now(),
  extracted_at TIMESTAMPTZ,
  error_message TEXT,
  CONSTRAINT valid_status CHECK (processing_status IN ('pending', 'processing', 'completed', 'failed'))
);

CREATE INDEX idx_bank_statements_user_status ON bank_statements(user_id, processing_status);
```

**point_transactions Table (from specifications/gamification-system.md):**

```sql
CREATE TABLE point_transactions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  points INT NOT NULL,
  reason VARCHAR(255),
  created_at TIMESTAMPTZ DEFAULT now()
);
```

### Component Specifications

**Upload Component:**

```tsx
// src/pages/onboarding/BankStatementUpload.tsx
import { useState } from 'react';
import { useDropzone } from 'react-dropzone';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { Progress } from '@/components/ui/progress';
import { useToast } from '@/hooks/use-toast';
import { uploadBankStatement } from '@/services/storageService';
import { triggerBankStatementProcessing } from '@/services/ocrService';
import { awardPoints } from '@/services/gamificationService';
import { useAuth } from '@/contexts/AuthContext';
import { useNavigate } from 'react-router-dom';
import { FileText, Upload } from 'lucide-react';

export default function BankStatementUpload() {
  const [file, setFile] = useState<File | null>(null);
  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const { user } = useAuth();
  const { toast } = useToast();
  const navigate = useNavigate();

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    accept: {
      'application/pdf': ['.pdf'],
      'text/csv': ['.csv'],
    },
    maxSize: 50 * 1024 * 1024, // 50MB
    multiple: false,
    onDrop: (acceptedFiles) => {
      if (acceptedFiles.length > 0) {
        setFile(acceptedFiles[0]);
      }
    },
    onDropRejected: (rejections) => {
      const error = rejections[0].errors[0];
      toast({
        title: 'Invalid file',
        description: error.code === 'file-too-large' 
          ? 'File is too large. Maximum size is 50MB.'
          : 'Please upload a PDF or CSV file.',
        variant: 'destructive',
      });
    },
  });

  const handleUpload = async () => {
    if (!file || !user) return;

    setUploading(true);

    try {
      // 1. Upload to Supabase Storage
      const filePath = await uploadBankStatement(file, user.id, (progress) => {
        setUploadProgress(progress);
      });

      // 2. Create database record
      const { data: statement, error: dbError } = await supabase
        .from('bank_statements')
        .insert({
          user_id: user.id,
          file_path: filePath,
          processing_status: 'pending',
        })
        .select('id')
        .single();

      if (dbError) throw dbError;

      // 3. Trigger OCR processing
      await triggerBankStatementProcessing(
        statement.id,
        user.id,
        filePath,
        'bank-statements'
      );

      // 4. Award gamification points
      await awardPoints(user.id, 5, 'First bank statement uploaded');

      toast({
        title: 'Upload successful!',
        description: 'Processing your statement now...',
      });

      // Navigate to processing status screen
      navigate(`/onboarding/processing/${statement.id}`);
    } catch (error) {
      console.error('Upload failed:', error);
      toast({
        title: 'Upload failed',
        description: error.message || 'Something went wrong. Please try again.',
        variant: 'destructive',
      });
    } finally {
      setUploading(false);
    }
  };

  return (
    <div className="min-h-screen bg-cream flex flex-col items-center justify-center p-4">
      <div className="max-w-2xl w-full">
        <h1 className="text-3xl font-bold text-charcoal mb-2">
          Upload Your Bank Statement
        </h1>
        <p className="text-stone mb-8">
          Upload a PDF or CSV file from your bank. We'll extract your account details and transactions.
        </p>

        <Card className="p-8">
          <div
            {...getRootProps()}
            className={`border-2 border-dashed rounded-lg p-12 text-center cursor-pointer transition-colors ${
              isDragActive ? 'border-charcoal bg-sand' : 'border-stone bg-white'
            }`}
          >
            <input {...getInputProps()} />
            <Upload className="w-12 h-12 mx-auto mb-4 text-stone" />
            {file ? (
              <div className="flex items-center justify-center gap-2">
                <FileText className="w-5 h-5 text-charcoal" />
                <span className="text-charcoal font-medium">{file.name}</span>
                <span className="text-stone text-sm">
                  ({(file.size / 1024 / 1024).toFixed(2)} MB)
                </span>
              </div>
            ) : (
              <div>
                <p className="text-charcoal font-medium mb-2">
                  {isDragActive ? 'Drop your file here' : 'Drag & drop your bank statement'}
                </p>
                <p className="text-stone text-sm">
                  or click to browse (PDF or CSV, max 50MB)
                </p>
              </div>
            )}
          </div>

          {uploading && (
            <div className="mt-6">
              <Progress value={uploadProgress} className="mb-2" />
              <p className="text-center text-stone text-sm">
                Uploading... {uploadProgress}%
              </p>
            </div>
          )}

          <Button
            size="lg"
            className="w-full mt-6"
            disabled={!file || uploading}
            onClick={handleUpload}
          >
            {uploading ? 'Uploading...' : 'Continue'}
          </Button>
        </Card>
      </div>
    </div>
  );
}
```

**Storage Service:**

```typescript
// src/services/storageService.ts
import { supabase } from '@/integrations/supabase/client';

export async function uploadBankStatement(
  file: File,
  userId: string,
  onProgress?: (progress: number) => void
): Promise<string> {
  const timestamp = Date.now();
  const filename = `${timestamp}_${file.name}`;
  const filePath = `${userId}/${filename}`;

  const { data, error } = await supabase.storage
    .from('bank-statements')
    .upload(filePath, file, {
      cacheControl: '3600',
      upsert: false,
      onUploadProgress: (progressEvent) => {
        if (onProgress && progressEvent.total) {
          const progress = Math.round((progressEvent.loaded / progressEvent.total) * 100);
          onProgress(progress);
        }
      },
    });

  if (error) {
    throw new Error(`Upload failed: ${error.message}`);
  }

  return data.path;
}
```

**OCR Service:**

```typescript
// src/services/ocrService.ts
import { supabase } from '@/integrations/supabase/client';

export async function triggerBankStatementProcessing(
  documentId: string,
  userId: string,
  filePath: string,
  storageBucket: string
): Promise<void> {
  const { data, error } = await supabase.functions.invoke('process-document', {
    body: {
      document_id: documentId,
      user_id: userId,
      document_type: 'bank_statement',
      file_path: filePath,
      storage_bucket: storageBucket,
    },
  });

  if (error) {
    throw new Error(`Failed to start processing: ${error.message}`);
  }

  // Edge function returns 202 Accepted
  console.log('Processing started:', data);
}
```

**Processing Status Hook:**

```typescript
// src/hooks/useProcessingStatus.ts
import { useQuery } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';

export function useProcessingStatus(documentId: string, documentType: 'bank_statement' | 'receipt') {
  return useQuery({
    queryKey: ['processing-status', documentId],
    queryFn: async () => {
      const table = documentType === 'bank_statement' ? 'bank_statements' : 'receipts';

      const { data, error } = await supabase
        .from(table)
        .select('processing_status, error_message')
        .eq('id', documentId)
        .single();

      if (error) throw error;

      return data;
    },
    refetchInterval: (data) => {
      // Stop polling if completed or failed
      if (data?.processing_status === 'completed' || data?.processing_status === 'failed') {
        return false;
      }
      // Poll every 2 seconds
      return 2000;
    },
    enabled: !!documentId,
  });
}
```

### File Locations

**New Files to Create:**
- `src/pages/onboarding/BankStatementUpload.tsx` - Upload UI component
- `src/pages/onboarding/ProcessingStatus.tsx` - Processing status display (optional separate page)
- `src/services/storageService.ts` - Supabase Storage upload logic
- `src/services/ocrService.ts` - Edge Function caller
- `src/hooks/useProcessingStatus.ts` - React Query hook for polling

**Existing Files to Reference:**
- `src/integrations/supabase/client.ts` - Supabase client
- `src/contexts/AuthContext.tsx` - User session
- `src/services/gamificationService.ts` - Award points function

**Edge Function to Create (separate task/story):**
- `supabase/functions/process-document/index.ts` - Edge Function

### Technical Constraints

**File Upload:**
- Use Supabase Storage SDK: `supabase.storage.from(bucket).upload()`
- Max file size enforced client-side (50MB) and server-side (Supabase limit)
- File path must be unique to avoid collisions (use timestamp)

**Edge Function Call:**
- Use Supabase Functions SDK: `supabase.functions.invoke()`
- Edge Function endpoint: `process-document`
- Returns 202 Accepted on success
- Async processing (don't wait for completion)

**Status Polling:**
- Use React Query `refetchInterval` for efficient polling
- Stop polling when status is terminal (`completed`, `failed`)
- Handle network errors gracefully (retry logic built into React Query)

**Error Handling:**
- Display user-friendly error messages
- Log detailed errors to console
- Provide retry option on failures
- Don't block onboarding if gamification points fail

### Testing Requirements

**Unit Tests:**
- File validation (type, size)
- Upload progress calculation
- Error message formatting

**Integration Tests:**
- Upload file to Supabase Storage (use test bucket)
- Create bank_statement record in database
- Call Edge Function (mock response)
- Award gamification points
- Status polling stops on completion

**E2E Tests:**
- Upload valid PDF → verify file in storage
- Upload invalid file → error message displays
- Upload → process → redirect to confirmation screen
- Upload → process fails → retry button works

### Security Considerations

- RLS policies on `bank_statements` table (user can only see their own)
- Supabase Storage bucket policy (user can only upload to their own folder)
- Signed URLs generated with 1 hour expiry for n8n access
- File path includes user_id to prevent unauthorized access

## Change Log

| Date       | Version | Description                    | Author |
|------------|---------|--------------------------------|--------|
| 2025-10-10 | 1.0     | Initial story draft (from PO) | Sarah  |

## Dev Agent Record

### Agent Model Used
<!-- Dev agent will update this section -->

### Debug Log References
<!-- Dev agent will log commands, test results, lint fixes here -->

### Completion Notes
<!-- Dev agent will document what was implemented, challenges, deviations -->

### File List
<!-- Dev agent will list all files created/modified/deleted -->

## QA Results

### Review Date: 2025-01-15

### Reviewed By: Quinn (Test Architect)

### Risk Assessment Summary

**Overall Story Risk: HIGH (Score 32/100)**

This story carries **CRITICAL SECURITY AND DATA INTEGRITY RISKS** that must be addressed before production deployment. Cross-referencing with Stories 1.9, 2.1, and 5.6 reveals systemic patterns of incomplete error handling, security controls, and testing coverage.

### Critical Findings Requiring Immediate Action

#### 1. Security Vulnerabilities (4 Critical Issues)
- **SEC-001**: No malware scanning on file uploads (Score: 9)
- **SEC-002**: Insufficient RLS policy validation on bank_statements table (Score: 9)
- **SEC-003**: Predictable file paths enable enumeration attacks (Score: 6)
- **SEC-004**: No audit trail for file access (Score: 4)

#### 2. Data Integrity Risks (3 Critical Issues)
- **DATA-001**: No backup strategy for original uploaded files (Score: 9)
- **DATA-002**: OCR processing failure could leave database in inconsistent state (Score: 6)
- **DATA-003**: No validation of extracted account details (Score: 4)

#### 3. Performance & Operational Concerns (9 High/Medium Issues)
- **PERF-001**: Synchronous processing could block UI for large files (Score: 9)
- **OPS-001**: No monitoring/alerting for failed uploads (Score: 6)
- **OPS-002**: Gamification points award could fail silently (Score: 6)
- **TECH-001**: Edge Function dependency on external n8n service (Score: 6)

### Cross-Story Pattern Analysis

**Pattern 1: Incomplete Error Handling** (Stories 1.9, 2.1, 2.2)
- Error handling consistently treats failures as "log and ignore"
- No retry mechanisms or recovery workflows
- User-facing operations lack proper fallback strategies

**Pattern 2: Security Controls Underspecified** (Stories 1.9, 2.1, 2.2)
- RLS policies mentioned but not comprehensively tested
- Input validation and sanitization incomplete
- Security reviews needed but not executed

**Pattern 3: Testing Coverage Gaps** (Stories 1.9, 5.6, 2.2)
- Testing sections documented but not consistently executed
- Integration tests failing or not run
- E2E tests specified but no evidence of execution

**Pattern 4: Gamification Fragility** (Stories 2.1, 5.6, 2.2)
- Gamification treated as non-critical "nice to have"
- No retry queues or failure recovery
- Silent failures leave users without rewards

### Must-Fix Items Before Production

**Security (Priority 1):**
1. Implement malware scanning (ClamAV or similar) before file storage
2. Add comprehensive RLS policy tests with cross-user access attempts
3. Replace timestamp-based file paths with UUIDs
4. Implement signed URLs with short expiry (1 hour)
5. Add file access audit logging

**Data Integrity (Priority 1):**
6. Implement automatic backup strategy with 7-year retention
7. Add OCR data validation layer with confidence scores
8. Implement "completed_with_errors" status for partial failures
9. Create manual review queue for low-confidence extractions

**Performance (Priority 1):**
10. Implement chunked file uploads (5MB chunks) for files > 10MB
11. Add proper upload progress tracking (bytes uploaded / total)
12. Implement background processing queue instead of synchronous calls
13. Add timeout handling and upload resume capability

**Operational (Priority 1):**
14. Configure monitoring and alerting (Sentry or similar)
15. Implement gamification retry queue with notification on failure
16. Add n8n health checks and circuit breaker pattern
17. Create ops dashboard for upload/processing health metrics

### Blocking Test Requirements

**Before merging to main:**
1. Security: Upload malicious PDF with embedded JavaScript → verify blocked
2. Security: Cross-user RLS test → User B cannot access User A's files
3. Security: File enumeration test → verify signed URLs required
4. Data: Backup verification → verify original recoverable after corruption
5. Performance: 50MB file upload test on throttled connection (1 Mbps)
6. Integration: n8n downtime simulation → verify retry logic works
7. Integration: Gamification failure test → verify retry queue captures failure

**Before production deployment:**
8. Penetration testing of file upload security
9. Load testing: 100 concurrent 50MB uploads
10. End-to-end testing with actual bank statements from major AU banks
11. Disaster recovery test: Restore from backup after simulated data loss

### Risk Distribution

- **Critical Risks (Score 9)**: 4 issues
- **High Risks (Score 6)**: 5 issues
- **Medium Risks (Score 4)**: 6 issues
- **Low Risks (Score 2-3)**: 3 issues

### Recommendations

**Immediate Actions:**
1. Do NOT proceed to production without addressing all Critical (Score 9) risks
2. Implement comprehensive security testing suite
3. Add monitoring and alerting infrastructure
4. Create error handling standards document for project
5. Establish testing execution as blocker for story completion

**Next Sprint:**
6. Address all High (Score 6) risks
7. Implement audit logging across all sensitive operations
8. Add performance optimization (CDN, chunked uploads)
9. Create disaster recovery playbook

**Technical Debt:**
10. Standardize error handling patterns across all stories
11. Implement comprehensive integration test suite
12. Add automated security scanning to CI/CD pipeline

### Gate Decision

**Gate: FAIL** → docs/qa/gates/2.2-bank-statement-upload-ocr.yml

**Status Reason:** Critical security vulnerabilities (no malware scanning, insufficient RLS validation, predictable file paths) and data integrity risks (no backup strategy, inconsistent state on failures) must be resolved before production deployment.

**Full Risk Profile:** docs/qa/assessments/2.2-risk-20250115.md  
**Test Design:** docs/qa/assessments/2.2-test-design-20250115.md

### Test Design Summary

**Test Strategy Created: 2025-01-15**

- **Total Test Scenarios**: 47 (18 unit, 21 integration, 8 E2E)
- **Priority Distribution**: P0: 15, P1: 22, P2: 10
- **Risk Score**: 32/100 (HIGH RISK) - Heavy security and data integrity focus
- **Component Reuse**: Adapting `useFileUpload.tsx` hook with security enhancements

**Critical Test Areas** (P0 - Must Pass):
1. **Security Tests** (5 scenarios):
   - SEC-001: Malware scanning integration with ClamAV
   - SEC-002: RLS policy validation (cross-user isolation)
   - SEC-003: File enumeration attack prevention (UUID paths)
   - SEC-004: File content validation (MIME type verification)

2. **Data Integrity Tests** (3 scenarios):
   - DATA-001: Backup creation before processing
   - DATA-002: Backup restoration after corruption
   - DATA-003: OCR extraction quality validation

3. **Performance Tests** (2 scenarios):
   - PERF-001: 50MB file uploads with chunking
   - Large file upload E2E test

4. **Core Integration Tests** (5 scenarios):
   - File upload to Supabase Storage
   - Database record creation with RLS
   - Edge Function OCR trigger
   - Status polling with React Query
   - E2E happy path flow

**New Components Required**:
- `src/hooks/useBankStatementUpload.tsx` - Extends useFileUpload with security
- `src/utils/fileSecurityValidator.ts` - MIME validation and malware scanning
- `src/utils/fileUploadHelpers.ts` - Shared logic for chunked uploads
- Test fixtures: Valid PDFs/CSVs, EICAR test file, 50MB test file

**Coverage Targets**:
- Unit Test Coverage: 80% (18 scenarios)
- Integration Test Coverage: 90% (21 scenarios)
- E2E Test Coverage: 100% of critical paths (8 scenarios)

### Recommended Next Steps

1. **IMMEDIATE (Before Development)**:
   - Integrate ClamAV malware scanner (CRITICAL - SEC-001)
   - Implement UUID-based file paths (CRITICAL - SEC-003)
   - Add chunked upload for files > 10MB (CRITICAL - PERF-001)
   - Create backup strategy (CRITICAL - DATA-001)

2. **Testing Phase**:
   - Execute all P0 security tests first (SEC-001 through SEC-004)
   - Validate RLS policies with cross-user tests (SEC-002)
   - Run performance tests with 50MB files (PERF-001)
   - Complete E2E happy path and security validation

3. **Before Production**:
   - All 15 P0 tests must pass
   - Security review meeting scheduled
   - Malware scanning verified with EICAR test file
   - Cross-user data isolation confirmed via E2E tests

4. **Post-Implementation**:
   - Run full test suite (47 scenarios)
   - Generate coverage report (target: 80% unit, 90% integration)
   - Update gate status based on test results
   - Schedule follow-up review for P1/P2 issues

**Do NOT set status to "Ready for Review" until**:
- Critical risks (Score 9) mitigated with passing tests
- All P0 tests executed and passing
- Security enhancements implemented (malware scanning, UUID paths)
- Test design approved by team
