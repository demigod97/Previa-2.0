# Story 4.2: AI Matching Algorithm

## Status: Draft

## Story

As a **Previa reconciliation engine**,  
I want **an AI matching algorithm that automatically pairs transactions with receipts based on date, amount, and description similarity**,  
So that **users can quickly approve suggested matches instead of manual searching**.

## Acceptance Criteria

**AC1: Matching Algorithm Implementation**
- PostgreSQL function or Edge Function implementation
- Match criteria: Date within ±3 days, amount exact or within $5, description similarity
- Calculate confidence score (0.0-1.0) based on match quality
- Store suggested matches in `reconciliation_matches` table with status='suggested'
- Run matching automatically when new receipts or transactions are added

**AC2: Date Matching Logic**
- Transaction date and receipt date within ±3 days = high confidence (0.8-1.0)
- Within ±7 days = medium confidence (0.5-0.79)
- Beyond ±7 days = low confidence (<0.5) or no match
- Exact date match adds +0.15 bonus to confidence score

**AC3: Amount Matching Logic**
- Exact amount match = high confidence (adds +0.30 to score)
- Within $5 = medium confidence (adds +0.15 to score)
- Beyond $5 = low confidence (no bonus) or no match
- Handle negative transaction amounts (debits) matching positive receipt amounts

**AC4: Description Similarity**
- Fuzzy text matching between transaction description and merchant name
- Use PostgreSQL pg_trgm extension for similarity scoring
- Similarity threshold: ≥0.3 for match consideration
- High similarity (≥0.6) adds +0.20 to confidence score
- Medium similarity (0.3-0.59) adds +0.10 to confidence score

**AC5: Confidence Score Calculation**
- Base score: 0.25
- Add date match bonus (0-0.15)
- Add amount match bonus (0-0.30)
- Add description similarity bonus (0-0.20)
- Add exact match bonuses if all criteria met (+0.10)
- Final score clamped to 0.0-1.0 range

**AC6: Batch Matching Trigger**
- Trigger matching automatically after bank statement import
- Trigger matching automatically after receipt upload and processing
- Manual "Find Matches" button in UI to run matching on-demand
- Process unreconciled transactions and receipts only

## Tasks / Subtasks

- [ ] **Task 1: Database Setup** (AC: 1)
  - [ ] 1.1: Enable pg_trgm extension in PostgreSQL
  - [ ] 1.2: Create `reconciliation_matches` table if not exists
  - [ ] 1.3: Add indexes on transaction_date, receipt_date, amount for performance
  - [ ] 1.4: Create similarity index on descriptions using pg_trgm

- [ ] **Task 2: Matching Function Implementation** (AC: 1, 2, 3, 4, 5)
  - [ ] 2.1: Create PostgreSQL function `find_reconciliation_matches(user_id UUID)`
  - [ ] 2.2: Query unreconciled transactions and receipts for user
  - [ ] 2.3: Implement date matching logic (±3 days high, ±7 days medium)
  - [ ] 2.4: Implement amount matching logic (exact or within $5)
  - [ ] 2.5: Implement description similarity using pg_trgm similarity()
  - [ ] 2.6: Calculate confidence score based on all criteria
  - [ ] 2.7: Insert matches into reconciliation_matches table with status='suggested'

- [ ] **Task 3: Confidence Score Calculation** (AC: 5)
  - [ ] 3.1: Base score = 0.25
  - [ ] 3.2: Date bonus: exact=+0.15, ±3 days=+0.10, ±7 days=+0.05
  - [ ] 3.3: Amount bonus: exact=+0.30, within $5=+0.15
  - [ ] 3.4: Description bonus: similarity ≥0.6=+0.20, 0.3-0.59=+0.10
  - [ ] 3.5: Perfect match bonus: if all exact=+0.10
  - [ ] 3.6: Clamp final score to 0.0-1.0

- [ ] **Task 4: Automatic Triggers** (AC: 6)
  - [ ] 4.1: Create database trigger: after transaction INSERT → run matching
  - [ ] 4.2: Create database trigger: after receipt status UPDATE to 'completed' → run matching
  - [ ] 4.3: Add debounce logic (run once per batch, not per row)
  - [ ] 4.4: Log trigger executions for debugging

- [ ] **Task 5: Manual Matching Function** (AC: 6)
  - [ ] 5.1: Create Edge Function `run-matching` for manual trigger
  - [ ] 5.2: Accept user_id parameter
  - [ ] 5.3: Call PostgreSQL matching function
  - [ ] 5.4: Return count of matches found
  - [ ] 5.5: Frontend button calls Edge Function

- [ ] **Task 6: Match Deduplication** (AC: 1)
  - [ ] 6.1: Prevent duplicate matches (same transaction + receipt pair)
  - [ ] 6.2: Update confidence score if match already exists
  - [ ] 6.3: Delete old suggested matches when new better match found

- [ ] **Task 7: Testing** (AC: 1, 2, 3, 4, 5, 6)
  - [ ] 7.1: Unit test date matching logic (within/beyond thresholds)
  - [ ] 7.2: Unit test amount matching logic (exact/within range)
  - [ ] 7.3: Unit test description similarity scoring
  - [ ] 7.4: Unit test confidence score calculation
  - [ ] 7.5: Integration test: insert transaction/receipt → verify match created
  - [ ] 7.6: Integration test: manual matching function
  - [ ] 7.7: Performance test: matching with 1000+ transactions/receipts

## Dev Notes

### Previous Story Insights

**From Story 2.4 (Transaction Preview):**
- Transactions inserted after bank statement processing
- Status initially 'unreconciled'

**From Story 3.4 (Receipt OCR):**
- Receipts status updated to 'completed' after OCR
- Merchant name and amount extracted

**From Story 4.1 (Library Views):**
- Unreconciled transactions and receipts displayed
- Filtering and searching patterns

### Architecture Context

**Matching Logic (from docs/prd.md):**
- AI-powered reconciliation matches transactions to receipts
- Confidence scoring helps users prioritize reviews
- Suggested matches require user approval

**Database Performance (from architecture/backend-architecture.md):**
- Use indexes for fast date/amount lookups
- pg_trgm extension for fuzzy text matching
- Batch processing for efficiency

**Frontend Integration (from architecture/unified-project-structure.md):**
- Edge Function for manual matching trigger
- Realtime updates when matches found

### Data Models

**reconciliation_matches Table:**

```sql
CREATE TABLE IF NOT EXISTS reconciliation_matches (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  transaction_id UUID NOT NULL REFERENCES transactions(id) ON DELETE CASCADE,
  receipt_id UUID NOT NULL REFERENCES receipts(id) ON DELETE CASCADE,
  confidence_score DECIMAL(3, 2) NOT NULL,  -- 0.00 to 1.00
  status VARCHAR(20) DEFAULT 'suggested',    -- 'suggested' | 'approved' | 'rejected'
  match_criteria JSONB,                      -- Stores why it matched
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  approved_at TIMESTAMPTZ,
  approved_by UUID REFERENCES auth.users(id),
  UNIQUE(transaction_id, receipt_id)         -- Prevent duplicate matches
);

CREATE INDEX idx_matches_user ON reconciliation_matches(user_id);
CREATE INDEX idx_matches_status ON reconciliation_matches(status);
CREATE INDEX idx_matches_confidence ON reconciliation_matches(confidence_score DESC);
CREATE INDEX idx_matches_transaction ON reconciliation_matches(transaction_id);
CREATE INDEX idx_matches_receipt ON reconciliation_matches(receipt_id);
```

**Match Criteria JSONB:**

```typescript
interface MatchCriteria {
  date_diff_days: number;        // Absolute days difference
  amount_diff: number;            // Absolute amount difference
  description_similarity: number; // pg_trgm similarity score 0.0-1.0
  exact_amount: boolean;
  exact_date: boolean;
  score_breakdown: {
    base: number;
    date_bonus: number;
    amount_bonus: number;
    description_bonus: number;
    perfect_match_bonus: number;
  };
}
```

### Component Specifications

**PostgreSQL Matching Function:**

```sql
-- Enable pg_trgm extension for text similarity
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- Create matching function
CREATE OR REPLACE FUNCTION find_reconciliation_matches(p_user_id UUID)
RETURNS TABLE (
  match_id UUID,
  transaction_id UUID,
  receipt_id UUID,
  confidence_score DECIMAL
) AS $$
DECLARE
  v_transaction RECORD;
  v_receipt RECORD;
  v_date_diff INTEGER;
  v_amount_diff DECIMAL;
  v_similarity DECIMAL;
  v_confidence DECIMAL;
  v_match_criteria JSONB;
BEGIN
  -- Loop through unreconciled transactions
  FOR v_transaction IN 
    SELECT id, transaction_date, description, amount
    FROM transactions
    WHERE user_id = p_user_id 
      AND status = 'unreconciled'
      AND id NOT IN (
        SELECT transaction_id 
        FROM reconciliation_matches 
        WHERE status IN ('suggested', 'approved')
      )
  LOOP
    -- Find matching receipts
    FOR v_receipt IN
      SELECT id, receipt_date, merchant, amount
      FROM receipts
      WHERE user_id = p_user_id
        AND status = 'unreconciled'
        AND id NOT IN (
          SELECT receipt_id 
          FROM reconciliation_matches 
          WHERE status IN ('suggested', 'approved')
        )
    LOOP
      -- Calculate date difference
      v_date_diff := ABS(v_transaction.transaction_date::DATE - v_receipt.receipt_date::DATE);
      
      -- Skip if date difference too large
      CONTINUE WHEN v_date_diff > 7;
      
      -- Calculate amount difference (handle negative transaction amounts)
      v_amount_diff := ABS(ABS(v_transaction.amount) - v_receipt.amount);
      
      -- Skip if amount difference too large
      CONTINUE WHEN v_amount_diff > 5;
      
      -- Calculate description similarity
      v_similarity := similarity(
        LOWER(v_transaction.description),
        LOWER(v_receipt.merchant)
      );
      
      -- Skip if similarity too low
      CONTINUE WHEN v_similarity < 0.3;
      
      -- Calculate confidence score
      v_confidence := 0.25;  -- Base score
      
      -- Date bonus
      IF v_date_diff = 0 THEN
        v_confidence := v_confidence + 0.15;
      ELSIF v_date_diff <= 3 THEN
        v_confidence := v_confidence + 0.10;
      ELSIF v_date_diff <= 7 THEN
        v_confidence := v_confidence + 0.05;
      END IF;
      
      -- Amount bonus
      IF v_amount_diff = 0 THEN
        v_confidence := v_confidence + 0.30;
      ELSIF v_amount_diff <= 5 THEN
        v_confidence := v_confidence + 0.15;
      END IF;
      
      -- Description similarity bonus
      IF v_similarity >= 0.6 THEN
        v_confidence := v_confidence + 0.20;
      ELSIF v_similarity >= 0.3 THEN
        v_confidence := v_confidence + 0.10;
      END IF;
      
      -- Perfect match bonus
      IF v_date_diff = 0 AND v_amount_diff = 0 AND v_similarity >= 0.8 THEN
        v_confidence := v_confidence + 0.10;
      END IF;
      
      -- Clamp to 0.0-1.0
      v_confidence := LEAST(GREATEST(v_confidence, 0.0), 1.0);
      
      -- Build match criteria JSON
      v_match_criteria := jsonb_build_object(
        'date_diff_days', v_date_diff,
        'amount_diff', v_amount_diff,
        'description_similarity', v_similarity,
        'exact_amount', v_amount_diff = 0,
        'exact_date', v_date_diff = 0
      );
      
      -- Insert or update match
      INSERT INTO reconciliation_matches (
        user_id,
        transaction_id,
        receipt_id,
        confidence_score,
        status,
        match_criteria
      )
      VALUES (
        p_user_id,
        v_transaction.id,
        v_receipt.id,
        v_confidence,
        'suggested',
        v_match_criteria
      )
      ON CONFLICT (transaction_id, receipt_id) DO UPDATE
      SET 
        confidence_score = EXCLUDED.confidence_score,
        match_criteria = EXCLUDED.match_criteria,
        updated_at = now()
      WHERE reconciliation_matches.confidence_score < EXCLUDED.confidence_score;
      
      -- Return the match
      match_id := (SELECT id FROM reconciliation_matches 
                   WHERE transaction_id = v_transaction.id 
                   AND receipt_id = v_receipt.id);
      transaction_id := v_transaction.id;
      receipt_id := v_receipt.id;
      confidence_score := v_confidence;
      
      RETURN NEXT;
    END LOOP;
  END LOOP;
  
  RETURN;
END;
$$ LANGUAGE plpgsql;
```

**Edge Function for Manual Matching:**

```typescript
// supabase/functions/run-matching/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: 'Missing authorization header' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: 'Invalid token' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Call matching function
    const { data, error } = await supabase.rpc('find_reconciliation_matches', {
      p_user_id: user.id,
    });

    if (error) {
      throw error;
    }

    const matchCount = data ? data.length : 0;

    return new Response(
      JSON.stringify({
        success: true,
        matches_found: matchCount,
        message: `Found ${matchCount} potential match${matchCount !== 1 ? 'es' : ''}`,
      }),
      { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('Error running matching:', error);
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
```

**Frontend Service:**

```typescript
// src/services/reconciliationService.ts
import { supabase } from '@/integrations/supabase/client';

export async function runMatching(): Promise<{ success: boolean; matchesFound: number }> {
  const { data, error } = await supabase.functions.invoke('run-matching', {});

  if (error) {
    throw new Error(`Failed to run matching: ${error.message}`);
  }

  return {
    success: data.success,
    matchesFound: data.matches_found,
  };
}

export async function getSuggestedMatches() {
  const { data, error } = await supabase
    .from('reconciliation_matches')
    .select(`
      *,
      transaction:transactions(*),
      receipt:receipts(*)
    `)
    .eq('status', 'suggested')
    .order('confidence_score', { ascending: false });

  if (error) throw error;
  return data;
}
```

### File Locations

**New Files to Create:**
- `supabase/migrations/YYYYMMDDHHMMSS_create_matching_function.sql` - Matching function and triggers
- `supabase/functions/run-matching/index.ts` - Manual matching Edge Function
- `src/services/reconciliationService.ts` - Frontend service for matching

**Database Setup:**
- Enable pg_trgm extension
- Create reconciliation_matches table
- Create indexes for performance

### Technical Constraints

**Performance:**
- Matching function should complete in <5 seconds for 1000 items
- Use indexes on date, amount, status fields
- Limit matching to unreconciled items only

**Accuracy:**
- False positives acceptable (user can reject)
- False negatives problematic (user must manually match)
- Balance threshold values for high recall

**Scalability:**
- Batch processing for large imports
- Debounce triggers (run once per batch, not per row)
- Consider background job for very large datasets

### Testing Requirements

**Unit Tests:**
- Date difference calculation
- Amount difference calculation (handle negatives)
- Confidence score calculation with various inputs
- Match criteria JSON generation

**Integration Tests:**
- Create transaction/receipt → verify match created
- Match deduplication (same pair)
- Confidence score update if better match found

**Performance Tests:**
- 1000 transactions + 1000 receipts matching time
- Query performance with indexes
- Concurrent matching requests

### Security Considerations

- RLS policies on reconciliation_matches table
- User can only see/modify their own matches
- Edge Function validates JWT token
- SQL injection prevented by parameterized queries

## Change Log

| Date       | Version | Description                    | Author |
|------------|---------|--------------------------------|--------|
| 2025-10-11 | 1.0     | Initial story draft (from PO) | Sarah  |

## Dev Agent Record

### Agent Model Used
<!-- Dev agent will update this section -->

### Debug Log References
<!-- Dev agent will log commands, test results, lint fixes here -->

### Completion Notes
<!-- Dev agent will document what was implemented, challenges, deviations -->

### File List
<!-- Dev agent will list all files created/modified/deleted -->

## QA Results
<!-- QA agent will append review results here -->
