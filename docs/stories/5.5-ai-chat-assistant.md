# Story 5.5: AI Chat Assistant

## Status: Draft

## Story

As a **Previa user seeking financial insights**,  
I want **an AI chat assistant that can answer questions about my transactions, receipts, and financial data**,  
So that **I can get instant insights and assistance without manually searching**.

## Acceptance Criteria

**AC1: Chat Interface UI**
- Chat view at `/dashboard/chat` route
- Message history display (scrollable container, auto-scroll to bottom)
- Input field with send button (Textarea auto-expand, Enter sends, Shift+Enter new line)
- AI assistant avatar and user avatar (distinct colors, initials or icons)
- Message bubbles (left for AI with cream background, right for user with sand background)
- Timestamps for each message

**AC2: AI Assistant Backend**
- Edge Function `ai-chat` that accepts message history
- System prompt with Previa context (user's data access, financial domain)
- Call OpenAI API (GPT-4 or GPT-3.5) or local LLM
- Streaming response support (display message as it's generated)
- Error handling (timeout, API errors, rate limits)

**AC3: Context-Aware Responses**
- AI can query user's transactions with natural language:
  - "Show my spending this month" → query transactions WHERE date >= start_of_month
  - "Find unreconciled transactions" → query WHERE status='unreconciled'
  - "How much did I spend on fuel?" → query WHERE category='Fuel'
- AI can query receipts:
  - "Show me recent receipts" → query receipts ORDER BY created_at DESC
  - "Which receipts are unmatched?" → query WHERE status='unmatched'
- AI can query accounts:
  - "What's my account balance?" → calculate sum of transactions per account

**AC4: Suggested Prompts**
- Display suggested prompts as clickable chips below input
- Suggestions:
  - "Show my spending this month"
  - "Find unreconciled transactions"
  - "Categorize my groceries"
  - "How much did I spend on fuel?"
  - "What's my largest expense?"
- Click chip → populate input and send message

**AC5: Chat History Persistence**
- Store messages in database (`messages` table with user_id, role, content, created_at)
- Load chat history on page mount (last 50 messages)
- Clear chat button (confirmation dialog)
- Each conversation as a separate chat session (optional future enhancement)

**AC6: Message Formatting**
- Render markdown in AI responses (bold, italic, lists, code blocks)
- Display transaction/receipt data in formatted tables
- Links are clickable (e.g., link to transaction details page)
- Code syntax highlighting (if AI provides code)

## Tasks / Subtasks

- [ ] **Task 1: Chat UI Component** (AC: 1)
  - [ ] 1.1: Create `src/pages/Chat.tsx`
  - [ ] 1.2: Message history container (scrollable, overflow-y-auto)
  - [ ] 1.3: Message bubbles (left for AI, right for user)
  - [ ] 1.4: Avatar components (AI: robot icon, User: initials from email)
  - [ ] 1.5: Timestamp display (format: "HH:mm" or "Yesterday at HH:mm")
  - [ ] 1.6: Auto-scroll to bottom on new message

- [ ] **Task 2: Input Field with Send Button** (AC: 1)
  - [ ] 2.1: Textarea component (auto-expand to fit content, max 5 rows)
  - [ ] 2.2: Send button (disabled while processing or input empty)
  - [ ] 2.3: Enter key sends message (Shift+Enter adds new line)
  - [ ] 2.4: Typing indicator while AI is generating response
  - [ ] 2.5: Focus input after sending message

- [ ] **Task 3: AI Chat Edge Function** (AC: 2)
  - [ ] 3.1: Create `supabase/functions/ai-chat/index.ts`
  - [ ] 3.2: Authenticate JWT token
  - [ ] 3.3: Accept { messages: { role, content }[], userId }
  - [ ] 3.4: System prompt: "You are a financial assistant for Previa..."
  - [ ] 3.5: Call OpenAI API with messages array
  - [ ] 3.6: Return streaming response (Server-Sent Events)
  - [ ] 3.7: Error handling (timeout 30s, API errors, rate limits)

- [ ] **Task 4: Context-Aware Function Calling** (AC: 3)
  - [ ] 4.1: Define OpenAI functions for data queries:
    - queryTransactions({ filters, dateFrom, dateTo, category, status })
    - queryReceipts({ status, dateFrom, dateTo })
    - getAccountBalance({ accountId })
    - getCategorySummary({ category, dateFrom, dateTo })
  - [ ] 4.2: Edge Function executes function calls (queries Supabase)
  - [ ] 4.3: Return query results to OpenAI for response generation
  - [ ] 4.4: AI formats results in natural language

- [ ] **Task 5: Suggested Prompts** (AC: 4)
  - [ ] 5.1: Display suggested prompts as chips below input
  - [ ] 5.2: Suggestions array (hardcoded for MVP)
  - [ ] 5.3: Click chip → set input value and auto-send
  - [ ] 5.4: Hide suggestions after user sends first message

- [ ] **Task 6: Chat History Persistence** (AC: 5)
  - [ ] 6.1: Create `messages` table in Supabase
    - Columns: id, user_id, role ('user' | 'assistant'), content, created_at
  - [ ] 6.2: Insert user message to database on send
  - [ ] 6.3: Insert AI response to database after generation
  - [ ] 6.4: Load last 50 messages on page mount
  - [ ] 6.5: "Clear Chat" button with confirmation dialog
  - [ ] 6.6: Delete all user's messages on clear

- [ ] **Task 7: Message Formatting** (AC: 6)
  - [ ] 7.1: Render markdown in AI responses (use react-markdown)
  - [ ] 7.2: Display transaction data in formatted tables (Table component)
  - [ ] 7.3: Syntax highlighting for code blocks (use react-syntax-highlighter)
  - [ ] 7.4: Clickable links (open in new tab)
  - [ ] 7.5: Bold/italic/lists rendering

- [ ] **Task 8: Typing Indicator** (AC: 1)
  - [ ] 8.1: Show "AI is typing..." with animated dots while waiting for response
  - [ ] 8.2: Display indicator at bottom of message list
  - [ ] 8.3: Hide indicator when response starts streaming

- [ ] **Task 9: Testing** (AC: 1, 2, 3, 4, 5, 6)
  - [ ] 9.1: Unit test message history loading
  - [ ] 9.2: Unit test markdown rendering
  - [ ] 9.3: Integration test send message → receive response
  - [ ] 9.4: Integration test function calling (query transactions)
  - [ ] 9.5: E2E test: send "Show my spending this month" → receive formatted response

## Dev Notes

### Previous Story Insights

**From Story 5.1 (Dashboard Layout):**
- Route: `/dashboard/chat` with AI Chat icon in sidebar

**From docs/n8n-integration-patterns.md:**
- Edge Function pattern (authentication, error handling)
- Webhook callback pattern

### Architecture Context

**AI Integration:**
- OpenAI API (GPT-4 or GPT-3.5-Turbo)
- Edge Function as middleware (Deno runtime)
- Streaming responses with Server-Sent Events

**Function Calling:**
- OpenAI function calling to query user data
- Edge Function executes queries on Supabase
- Returns results to OpenAI for natural language formatting

### Data Models

**Message (chat history):**

```typescript
interface Message {
  id: string;
  user_id: string;
  role: 'user' | 'assistant';
  content: string;
  created_at: string;
}
```

**AI Chat Request:**

```typescript
interface AIChatRequest {
  messages: { role: 'user' | 'assistant' | 'system'; content: string }[];
  userId: string;
}
```

**OpenAI Function Definitions:**

```typescript
const functions = [
  {
    name: 'queryTransactions',
    description: 'Query user transactions with filters',
    parameters: {
      type: 'object',
      properties: {
        dateFrom: { type: 'string', description: 'Start date YYYY-MM-DD' },
        dateTo: { type: 'string', description: 'End date YYYY-MM-DD' },
        category: { type: 'string', description: 'Transaction category' },
        status: { type: 'string', enum: ['unreconciled', 'reconciled', 'ignored'] },
      },
    },
  },
  {
    name: 'queryReceipts',
    description: 'Query user receipts',
    parameters: {
      type: 'object',
      properties: {
        status: { type: 'string', enum: ['pending', 'processing', 'completed', 'failed'] },
        dateFrom: { type: 'string' },
        dateTo: { type: 'string' },
      },
    },
  },
  {
    name: 'getAccountBalance',
    description: 'Get account balance (sum of transactions)',
    parameters: {
      type: 'object',
      properties: {
        accountId: { type: 'string', description: 'Bank account ID' },
      },
    },
  },
];
```

### Component Specifications

**Chat Page:**

```tsx
// src/pages/Chat.tsx
import { useState, useEffect, useRef } from 'react';
import { useAuth } from '@/contexts/AuthContext';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Avatar, AvatarFallback } from '@/components/ui/avatar';
import { Send, Loader2 } from 'lucide-react';
import { sendChatMessage, loadChatHistory } from '@/services/chatService';
import ReactMarkdown from 'react-markdown';
import type { Message } from '@/types/chat';

export default function Chat() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const { user } = useAuth();

  useEffect(() => {
    loadHistory();
  }, []);

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const loadHistory = async () => {
    const history = await loadChatHistory(user.id);
    setMessages(history);
  };

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  const handleSend = async () => {
    if (!input.trim()) return;

    const userMessage: Message = {
      id: crypto.randomUUID(),
      user_id: user.id,
      role: 'user',
      content: input,
      created_at: new Date().toISOString(),
    };

    setMessages((prev) => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      const response = await sendChatMessage([...messages, userMessage]);

      const assistantMessage: Message = {
        id: crypto.randomUUID(),
        user_id: user.id,
        role: 'assistant',
        content: response.content,
        created_at: new Date().toISOString(),
      };

      setMessages((prev) => [...prev, assistantMessage]);
    } catch (error) {
      console.error('Chat error:', error);
      // Show error toast
    } finally {
      setIsLoading(false);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  const suggestedPrompts = [
    'Show my spending this month',
    'Find unreconciled transactions',
    'Categorize my groceries',
    'How much did I spend on fuel?',
    "What's my largest expense?",
  ];

  return (
    <div className="flex flex-col h-[calc(100vh-4rem)] p-8">
      <div className="mb-6">
        <h1 className="text-3xl font-bold text-charcoal">AI Chat Assistant</h1>
        <p className="text-stone">Ask questions about your financial data</p>
      </div>

      {/* Messages */}
      <div className="flex-1 overflow-y-auto mb-4 space-y-4">
        {messages.map((message) => (
          <div
            key={message.id}
            className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}
          >
            <div className={`flex gap-3 max-w-[80%] ${message.role === 'user' ? 'flex-row-reverse' : ''}`}>
              <Avatar>
                <AvatarFallback className={message.role === 'user' ? 'bg-sand' : 'bg-cream'}>
                  {message.role === 'user' ? user.email?.charAt(0).toUpperCase() : 'AI'}
                </AvatarFallback>
              </Avatar>
              <div
                className={`rounded-lg p-4 ${
                  message.role === 'user' ? 'bg-sand' : 'bg-cream'
                }`}
              >
                {message.role === 'assistant' ? (
                  <ReactMarkdown className="prose prose-sm">
                    {message.content}
                  </ReactMarkdown>
                ) : (
                  <p className="text-sm">{message.content}</p>
                )}
                <p className="text-xs text-stone mt-2">
                  {new Date(message.created_at).toLocaleTimeString()}
                </p>
              </div>
            </div>
          </div>
        ))}

        {isLoading && (
          <div className="flex justify-start">
            <div className="flex gap-3">
              <Avatar>
                <AvatarFallback className="bg-cream">AI</AvatarFallback>
              </Avatar>
              <div className="rounded-lg p-4 bg-cream">
                <Loader2 className="h-4 w-4 animate-spin" />
                <p className="text-xs text-stone mt-1">AI is typing...</p>
              </div>
            </div>
          </div>
        )}

        <div ref={messagesEndRef} />
      </div>

      {/* Suggested Prompts */}
      {messages.length === 0 && (
        <div className="mb-4 flex flex-wrap gap-2">
          {suggestedPrompts.map((prompt) => (
            <Button
              key={prompt}
              variant="outline"
              size="sm"
              onClick={() => {
                setInput(prompt);
                setTimeout(() => handleSend(), 100);
              }}
            >
              {prompt}
            </Button>
          ))}
        </div>
      )}

      {/* Input */}
      <div className="flex gap-2">
        <Textarea
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="Ask me anything about your finances..."
          className="resize-none"
          rows={2}
        />
        <Button onClick={handleSend} disabled={!input.trim() || isLoading}>
          <Send className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}
```

**AI Chat Edge Function:**

```typescript
// supabase/functions/ai-chat/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import OpenAI from 'https://esm.sh/openai@4';

const openai = new OpenAI({
  apiKey: Deno.env.get('OPENAI_API_KEY'),
});

serve(async (req) => {
  try {
    // Authenticate
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) throw new Error('Missing auth header');

    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_ANON_KEY')!,
      { global: { headers: { Authorization: authHeader } } }
    );

    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();
    if (authError || !user) throw new Error('Unauthorized');

    // Parse request
    const { messages } = await req.json();

    // System prompt
    const systemPrompt = {
      role: 'system',
      content: `You are a helpful financial assistant for Previa, an AI-driven financial intelligence platform for Australian freelancers. You have access to the user's transactions, receipts, and bank accounts. Answer questions concisely and provide actionable insights. When displaying data, format it in markdown tables.`,
    };

    // Function definitions
    const functions = [
      {
        name: 'queryTransactions',
        description: 'Query user transactions with optional filters',
        parameters: {
          type: 'object',
          properties: {
            dateFrom: { type: 'string', description: 'Start date YYYY-MM-DD' },
            dateTo: { type: 'string', description: 'End date YYYY-MM-DD' },
            category: { type: 'string', description: 'Category filter' },
            status: { type: 'string', enum: ['unreconciled', 'reconciled', 'ignored'] },
          },
        },
      },
      // Add more functions...
    ];

    // Call OpenAI
    const completion = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [systemPrompt, ...messages],
      functions,
      function_call: 'auto',
      temperature: 0.7,
    });

    const responseMessage = completion.choices[0].message;

    // Handle function calls
    if (responseMessage.function_call) {
      const functionName = responseMessage.function_call.name;
      const functionArgs = JSON.parse(responseMessage.function_call.arguments);

      // Execute function (e.g., queryTransactions)
      let functionResult;
      if (functionName === 'queryTransactions') {
        const { data } = await supabase
          .from('transactions')
          .select('*')
          .gte('transaction_date', functionArgs.dateFrom || '1900-01-01')
          .lte('transaction_date', functionArgs.dateTo || '2100-12-31')
          .eq('category', functionArgs.category || undefined)
          .eq('status', functionArgs.status || undefined);

        functionResult = JSON.stringify(data);
      }

      // Call OpenAI again with function result
      const secondCompletion = await openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          systemPrompt,
          ...messages,
          responseMessage,
          { role: 'function', name: functionName, content: functionResult },
        ],
      });

      return new Response(
        JSON.stringify({ content: secondCompletion.choices[0].message.content }),
        { headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Return response
    return new Response(JSON.stringify({ content: responseMessage.content }), {
      headers: { 'Content-Type': 'application/json' },
    });
  } catch (error) {
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
});
```

**Chat Service:**

```typescript
// src/services/chatService.ts
import { supabase } from '@/lib/supabase';
import type { Message } from '@/types/chat';

export async function loadChatHistory(userId: string): Promise<Message[]> {
  const { data, error } = await supabase
    .from('messages')
    .select('*')
    .eq('user_id', userId)
    .order('created_at', { ascending: true })
    .limit(50);

  if (error) throw error;
  return data || [];
}

export async function sendChatMessage(messages: Message[]): Promise<{ content: string }> {
  const response = await fetch(`${import.meta.env.VITE_SUPABASE_URL}/functions/v1/ai-chat`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${(await supabase.auth.getSession()).data.session?.access_token}`,
    },
    body: JSON.stringify({ messages }),
  });

  if (!response.ok) throw new Error('Chat request failed');

  return await response.json();
}

export async function clearChatHistory(userId: string) {
  const { error } = await supabase.from('messages').delete().eq('user_id', userId);
  if (error) throw error;
}
```

### File Locations

**New Files to Create:**
- `src/pages/Chat.tsx` - Chat UI
- `src/services/chatService.ts` - Chat API functions
- `supabase/functions/ai-chat/index.ts` - Edge Function for AI chat
- `supabase/migrations/XXXXXX_create_messages_table.sql` - Messages table

**Database Migration:**

```sql
-- supabase/migrations/XXXXXX_create_messages_table.sql
CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('user', 'assistant')),
  content TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_messages_user_id ON messages(user_id);
CREATE INDEX idx_messages_created_at ON messages(created_at);

-- RLS policies
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own messages"
  ON messages FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own messages"
  ON messages FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own messages"
  ON messages FOR DELETE
  USING (auth.uid() = user_id);
```

### Technical Constraints

**OpenAI API:**
- Rate limits (3 requests/min for free tier)
- Timeout: 30 seconds per request
- Token limits (GPT-4: 8K tokens, GPT-3.5: 4K tokens)

**Streaming Responses:**
- Use Server-Sent Events for streaming
- Display message as it's generated (future enhancement)

**Function Calling:**
- Limit function calls to user's own data (RLS policies)
- Validate function arguments

### Testing Requirements

**Unit Tests:**
- Message history loading
- Markdown rendering
- Suggested prompt click

**Integration Tests:**
- Send message → receive response
- Function calling (queryTransactions)
- Clear chat history

**E2E Tests:**
- Navigate to /dashboard/chat
- Send message "Show my spending this month"
- Receive formatted response with transaction data
- Clear chat → messages deleted

### Security Considerations

- All messages filtered by user_id (RLS policies)
- Edge Function authenticates JWT token
- Function calls only access user's own data
- OpenAI API key stored in environment variables

## Change Log

| Date       | Version | Description                    | Author |
|------------|---------|--------------------------------|--------|
| 2025-10-11 | 1.0     | Initial story draft (from PO) | Sarah  |

## Dev Agent Record

### Agent Model Used
<!-- Dev agent will update this section -->

### Debug Log References
<!-- Dev agent will log commands, test results, lint fixes here -->

### Completion Notes
<!-- Dev agent will document what was implemented, challenges, deviations -->

### File List
<!-- Dev agent will list all files created/modified/deleted -->

## QA Results
<!-- QA agent will append review results here -->
